[
  "markdown\n### 标题\n```markdown\n# 一级标题",
  "markdown\n### 强调\n```markdown\n*斜体*",
  "markdown\n### 列表\n```markdown\n* Item 1",
  "markdown\n### 链接\n```markdown\n[百度](https://www.baidu.com)",
  "markdown\n### 图片\n```markdown\n![Image alt text](/path/to/img.jpg)",
  "markdown\n### 代码\n```markdown\n4空格缩进",
  "markdown\n### 区块引用\n```markdown\n> 这是",
  "markdown\n### 水平线\n```markdown\n----",
  "markdown\n### 表格\n```markdown",
  "mysql\n### 登录\n```bash\nmysql -u [username] -p;",
  "mysql\n### 浏览\n```sql\nSHOW DATABASES;",
  "mysql\n### 查询 / SELECT\n```sql\nSELECT * FROM table;",
  "mysql\n### 连接查询\n```sql\nSELECT ... FROM t1 JOIN t2 ON t1.id1 = t2.id2 WHERE condition;",
  "mysql\n### 查询条件\n```sql\nfield1 = value1",
  "mysql\n### 创建/打开/删除/修改 数据库\n```sql\nCREATE DATABASE DatabaseName;",
  "mysql\n### 备份数据库\n// TODO\n```bash",
  "mysql\n### 恢复数据库\n```bash\nmysql - u Username -p DatabaseName < databasename_backup.sql;",
  "mysql\n### 异常关闭后修复数据库\n// TODO\n```bash",
  "mysql\n### 插入 / INSERT\n```sql\nINSERT INTO table1 (field1, field2) VALUES (value1, value2);",
  "mysql\n### 删除 / DELETE\n```sql\nDELETE FROM table1 / TRUNCATE table1",
  "mysql\n### 更新 / UPDATE\n```sql\nUPDATE table1 SET field1=new_value1 WHERE condition;",
  "mysql\n### 新建/删除/修改 表\n#### 新建 / CREATE\n```sql\nCREATE TABLE table (field1 type1, field2 type2);",
  "mysql\n#### 删除 - DROP\n```sql\nDROP TABLE table;",
  "mysql\n#### 修改 - ALTER\n```sql\nALTER TABLE table MODIFY field1 type1",
  "mysql\n#### 修改默认排序\n```sql\nALTER TABLE table MODIFY field1 type1 FIRST",
  "mysql\n### 键\n```sql\nCREATE TABLE table (..., PRIMARY KEY (field1, field2))",
  "mysql\n### 用户和授权\n```sql\nCREATE USER 'user'@'localhost';",
  "mysql\n### 主要数据类型\n```sql\nTINYINT (1o: -217+128)",
  "mysql\n### 重置root账户密码\n```bash\n$ /etc/init.d/mysql stop",
  "bash\n### 示例\n```bash\n#!/usr/bin/env bash",
  "bash\n### 变量\n```bash\nNAME=\"John\"",
  "bash\n### 字符串引号\n```bash\nNAME=\"John\"",
  "bash\n### Shell执行\n```bash\necho \"I'm in $(pwd)\"",
  "bash\n### 条件执行\n```bash\ngit commit && git push",
  "bash\n### 函数\n```bash\nget_name() {",
  "bash\n### 条件判断\n```bash\nif [[ -z \"$string\" ]]; then",
  "bash\n### Strict 模式\n```bash\nset -euo pipefail",
  "bash\n### 花括号展开\n```bash\necho {A,B}.js",
  "bash\n## 参数扩展\n### 基本使用\n```bash\nname=\"John\"",
  "bash\n### 替换\n`%rule`删除`rule`到结束匹配的内容，`#rule`删除开始到`rule`匹配的内容，即`%`删除后缀、`#`删除前缀。\n另外，默认为最小匹配，叠字`%%`、`##`为贪婪匹配。",
  "bash\n### 注释\n```bash\n# Single line comment",
  "bash\n### 子串",
  "bash\n### 长度",
  "bash\n### 操作\n```bash\nSTR=\"HELLO WORLD!\"",
  "bash\n### 默认值",
  "bash\n## 循环\n### 基本循环\n```bash\nfor i in /etc/rc*; do",
  "bash\n### C-like 循环\n```bash\nfor ((i = 0 ; i < 100 ; i++)); do",
  "bash\n### 范围\n```bash\nfor i in {1..5}; do",
  "bash\n#### 带步长的范围\n```bash\nfor i in {5..50..5}; do",
  "bash\n### 读取行\n```bash\ncat file.txt | while read line; do",
  "bash\n### 死循环\n```bash\nwhile true; do",
  "bash\n## 函数\n### 定义函数\n```bash\nmyfunc() {",
  "bash\n### 返回值\n```bash\nmyfunc() {",
  "bash\n### 引发错误\n```bash\nmyfunc() {",
  "bash\n### 参数",
  "bash\n## 条件语句\n### 条件\n`[[`会返回`0`(假)或`1`(真)，其他任意遵守相同逻辑的程序均可以作为条件，详见示例。",
  "bash\n#### 更多条件",
  "bash\n### 文件条件",
  "bash\n### 示例\n#### 字符串\n```bash\nif [[ -z \"$string\" ]]; then",
  "bash\n#### 组合\n```bash\nif [[ X && Y ]]; then",
  "bash\n#### 相等\n```bash\nif [[ \"$A\" == \"$B\" ]]",
  "bash\n#### 正则\n```bash\nif [[ \"A\" =~ . ]]",
  "bash\n#### 数值\n```bash\nif (( $a < $b )); then",
  "bash\n#### 文件\n```bash\nif [[ -e \"file.txt\" ]]; then",
  "bash\n## 数组\n### 定义数组\n```bash\nFruits=('Apple' 'Banana' 'Orange')",
  "bash\n### 数组使用\n```bash\necho ${Fruits[0]}           # 第一个元素 #0",
  "bash\n### 操作\n```bash\nFruits=(\"${Fruits[@]}\" \"Watermelon\")    # Push",
  "bash\n### 变量\n```bash\nfor i in \"${arrayName[@]}\"; do",
  "bash\n## 字典\n### 定义\n```bash\ndeclare -A sounds",
  "bash\n### 字典使用\n```bash\necho ${sounds[dog]} # 按key取值",
  "bash\n### 遍历\n#### 值遍历\n```bash\nfor val in \"${sounds[@]}\"; do",
  "bash\n#### 键遍历\n```bash\nfor key in \"${!sounds[@]}\"; do",
  "bash\n## 选项\n### 选项\n```bash\nset -o noclobber  # 避免覆盖文件 (echo \"hi\" > foo)",
  "bash\n### 扩展选项\n```bash\nshopt -s nullglob    # 移除不匹配扩展项 ('*.foo' => '')",
  "bash\n## 历史\n### 命令",
  "bash\n### 表达式",
  "bash\n### 操作",
  "bash\n### 切分",
  "bash\n## 杂项\n### 数值计算\n```bash\n$((a + 200))      # $a加上200",
  "bash\n### 子脚本\n```bash\n(cd somedir; echo \"I'm now in $PWD\")",
  "bash\n### 重定向\n```bash\npython hello.py > output.txt   # 标准输出到（文件）",
  "bash\n### 检查命令\n```bash\ncommand -V cd",
  "bash\n### 捕获错误\n```bash\ntrap 'echo Error at about $LINENO' ERR",
  "bash\n### Case/switch\n```bash\ncase \"$1\" in",
  "bash\n### Source relative\n```bash\nsource \"${0%/*}/../share/foo.sh\"",
  "bash\n### printf\n```bash\nprintf \"Hello %s, I'm %s\" Sven Olga",
  "bash\n### Directory of script\n```bash\nDIR=\"${0%/*}\"",
  "bash\n### 获取选项\n```bash\nwhile [[ \"$1\" =~ ^- && ! \"$1\" == \"--\" ]]; do case $1 in",
  "bash\n### Heredoc\n```sh\ncat <<END",
  "bash\n### 读取输入\n```bash\necho -n \"Proceed? [y/n]: \"",
  "bash\n### 特殊变量",
  "bash\n### 返回先前目录\n```bash\ncd -",
  "bash\n### 命令结果检查\n```bash\nif ping -c 1 google.com; then",
  "bash\n### GREP结果检查\n```bash\nif grep -q 'foo' ~/.bash_history; then",
  "bash\n## 更多\n- [Bash-hackers wiki](http://wiki.bash-hackers.org/) _(bash-hackers.org)_\n- [Shell vars](http://wiki.bash-hackers.org/syntax/shellvars) _(bash-hackers.org)_",
  "vim\n### 退出",
  "vim\n### 导航",
  "vim\n#### 单词",
  "vim\n#### 行",
  "vim\n#### 字符",
  "vim\n#### 文档",
  "vim\n#### 窗口",
  "vim\n#### 查找",
  "vim\n#### Tab页",
  "vim\n### 编辑",
  "vim\n### 退出插入模式",
  "vim\n### 剪贴板",
  "vim\n### 视觉模式",
  "vim\n#### 在视觉模式中",
  "vim\n## 操作指令\n### 使用\n这些在正常模式下执行，根据*指令范围*不同，操作指定能操作一定区域的文本。",
  "vim\n### 操作指令列表",
  "vim\n### 示例\n结合*指令范围*来应用操作指令。",
  "vim\n## 文本对象\n### 使用\n文本对象使您可以在文本块中或周围进行操作（使用*操作指令*）。",
  "vim\n### 文本对象",
  "vim\n### Examples",
  "vim\n### Diff",
  "vim\n## 杂项\n{column_size: 2}\n### 折叠",
  "vim\n### 导航",
  "vim\n### 跳转",
  "vim\n### 计数器",
  "vim\n### 窗口",
  "vim\n### 标签",
  "vim\n### 大小写",
  "vim\n### 标记",
  "vim\n### 杂项",
  "vim\n### 命令行",
  "vim\n### 文本对齐\n```\n:center [width]",
  "vim\n### 计算",
  "vim\n### 错误退出\n```\n:cq",
  "vim\n### 拼写检查",
  "vim\n## 更多\n- [Vim cheatsheet](https://vim.rtorr.com/) _(vim.rotrr.com)_\n- [Vim documentation](http://vimdoc.sourceforge.net/htmldoc/) _(vimdoc.sourceforge.net)_",
  "powershell\n### 帮助\n```shell\nGet-Help alias",
  "powershell\n### 文件和路径\n```shell\nGet-ChildItem [path]; ls; dir       # 子对象列表",
  "powershell\n### 句法要素",
  "powershell\n#### 三元运算\n```shell\nswitch(boolExpr) {",
  "powershell\n### 显示选项",
  "powershell\n#### 格式化 + 过滤\n```shell\n# table化输出到文件",
  "powershell\n### 提示和暂停",
  "powershell\n## 语法\n### 变量\n```shell\n$a = 25; $a                                 #=> 25",
  "powershell\n### 参数传递\n```shell\nfunction func($a,$b) {",
  "powershell\n### 属性\n```shell\ngm -input (1..5) -name count                  # 尝试获取属性",
  "powershell\n### 对象、类型和转型\n```shell\n@(Get-Process).Count                           # 集合大小",
  "git\n### 配置\n```bash\ngit config --global \"Your Name\"",
  "git\n### 初始化\n```bash\ngit init",
  "git\n###  提交修改\n```bash\ngit add <file>",
  "git\n### 查看状态、比对\n```bash\ngit status",
  "git\n#### 文件状态缩略信息",
  "git\n## Git Log\n### log 记录和对比\n```bash\ngit log",
  "git\n### log 格式化\n```bash\ngit log <branch_name> --oneline                     # 对提交历史单行排列",
  "git\n#### git log --pretty=format 常用的选项(摘自progit_v2.1.9)",
  "git\n### log 时间和提交者\n```bash\ngit log --since --after     # 显示时间之后的提交",
  "git\n## 版本管理\n### 版本回退、前进\n```bash\ngit reset --hard HEAD^   # 回退到上1版本",
  "git\n### 撤销修改\n```bash\ngit checkout -- <file>   # 撤销修改：误修改工作区文件，未git add/commit",
  "git\n### 删除与恢复\n```bash\ngit rm/add <file>",
  "git\n### 清理工作区\n包括未track也未ignore的文件或文件夹，如各种临时.swp, .patch文件等\n```bash",
  "git\n## 仓库与分支\n### 关联GitHub远程仓库（本地到远程）\n```bash\ngit remote add origin <remote address>  # 在本地工作区目录下按照 GitHub 提示进行关联",
  "git\n### 克隆GitHub远程仓库（远程到本地）\n```bash\ngit clone <remote address>  # git协议速度更快但通常公司内网不允许，https协议速度慢",
  "git\n### 分支管理：创建、切换、查看、合并、删除\n```bash\ngit branch <branch name>       # 创建<branch name>分支",
  "git\n### 解决合并冲突\n合并时报错“分支发生冲突”，首先vim相应文件，修改冲突位置，然后按照git add/commit重新提交，最后删除多余分支即可。\n```bash",
  "git\n### 分支管理：合并后删除分支也在 log 中保留分支记录\n```bash\ngit merge --no-ff -m \"descriptions\" <branch name>",
  "git\n### 开发流程",
  "git\n### Bug分支管理（建立单独分支进行bug修复）\n软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。\n```bash",
  "git\n### Feature分支管理（建立单独分支添加新功能）\n软件开发中，总有无穷无尽的新的功能要不断添加进来。添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。\n```bash",
  "git\n### 协作与分支推送\n#### User 1:\n```bash\ngit remote [-v]                   # 查看远程库信息（-v 查看详细信息）",
  "git\n#### User 2:\n```bash\ngit clone <remote address>      # 克隆到本地（只能克隆master）",
  "git\n#### User 1:\n```bash\ngit add/commit/push          # 推送时报错（与user 2推送的更新冲突）",
  "git\n### 标签管理（常用于版本管理）：查看、创建、操作\n```bash\ngit tag                           # 查看标签",
  "git\n## rebase(换基)\n### 目的\n`rebase`在日常中常用功能主要是两个，多人协同开发定期`rebase master`，以及压缩某分支多个`commit`。\n`git rebase master`常见于多人开发，每个开发人员从`master` `checkout`出自己的分支，开发一段时间后提交至`master`之前最好`rebase`一下，防止冲突，就算真有冲突在本地解决好过强制提交，开发流程中尽量保证master的干净整洁。\n### 案例一\n`master`分支上有三个提交`C1`, `C2`, `C3`\n某一时刻`usr1`在`C3`的`master`分支上`checkout`出新的分支, 用于开发服务端支持`ipv6`新特性, 并提交了`C4`, `C5`",
  "git\n### 案例二\n// TODO\n```bash",
  "git\n#### 提交后分支状态如下\n```markup\n(client branch)",
  "git\n### 其他\n```bash\n# 压缩当前分支的n个commit并合并为1个commit, 常见第一行为pick, 剩下的n-1行为squash",
  "git\n## 杂项\n{column_size: 1}\n### 打patch(补丁)\n#### 生成diff patch文件(git可以识别diff文件)\n```bash\ngit <branch> log -n -p > diff.patch # 生成某分支过去n个commit的文件diff信息至单个diff文件",
  "git\n#### 利用apply打patch\n```bash\ngit apply --check diff.patch    # 检查是否可以正常应用, 无回显证明无冲突",
  "git\n#### 利用--format-patch生成patch, 带commit信息\n```bash\ngit format-patch <branch> -n    # 生成分支<branch>最近的n次commit的patch",
  "git\n#### 利用am打patch\n```bash\ngit apply --check 0001-update-bash.sh.patch # 检查patch是否冲突可用",
  "git\n### bundle(打包)\n该命令会将git工程打包, 默认情况下会打包所有commit记录和track的文件\n不同于简单粗暴tar.gz打包整个文件夹, bundle只打包那些push过的记录",
  "git\n#### bundle也可以打包指定的区间, 至于提交区间有多种表示方式\n```bash\ngit bundle create awesome-cheatsheets.bundle HEAD~10",
  "git\n### 使用GitHub\n```markup\nfork --> clone --> add/commit/push --> pull request",
  "git\n### 其他配置\n```bash\ngit config --global color.ui true  # 显示颜色",
  "git\n### 配置.gitignore文件\n```markup\n/<dir name>/               # 忽略文件夹",
  "git\n#### 文件.gitignore生效后\n```bash\ngit add -f <file>           # 强制添加",
  "git\n### 配置别名\n```bash\ngit config [--global] alias.<alias> '<original command>'  # 为所有工作区/当前工作区配置别名",
  "es6\n### 块作用域\n#### Let\n```js\nfunction fn () {",
  "es6\n#### Const\n```js\nconst a = 1",
  "es6\n### 反引号\n#### 字符串模板\n```js\nconst message = `Hello ${name}`",
  "es6\n#### 多行文本\n```js\nconst str = `",
  "es6\n### 二进制和八进制\n```js\nlet bin = 0b1010010",
  "es6\n### 新方法\n#### string的新方法\n```js\n\"hello\".repeat(3)",
  "es6\n### 类\n```js\nclass Circle extends Shape {",
  "es6\n#### 构造器\n```js\nconstructor (radius) {",
  "es6\n#### 方法\n```js\ngetArea () {",
  "es6\n#### 调用父类方法\n```js\nexpand (n) {",
  "es6\n#### 静态方法\n```js\nstatic createFromDiameter(diameter) {",
  "es6\n### 指数计算\n```js\nconst byte = 2 ** 8",
  "es6\n## Promises\n### 创建 promises\n```js\nnew Promise((resolve, reject) => {",
  "es6\n### 使用 promises\n```js\npromise",
  "es6\n### promises 使用 finally\n```js\npromise",
  "es6\n### Promise 方法\n```js\nPromise.all(···)",
  "es6\n### Async-await\n```js\nasync function run () {",
  "es6\n## 解构\n### 解构赋值\n#### Arrays\n```js\nconst [first, last] = ['Nikola', 'Tesla']",
  "es6\n#### Objects\n```js\nlet {title, author} = {",
  "es6\n### 默认值\n```js\nconst scores = [22, 33]",
  "es6\n### 方法参数\n```js\nfunction greet({ name, greeting }) {",
  "es6\n### 方法参数默认值\n```js\nfunction greet({ name = 'Rauno' } = {}) {",
  "es6\n### 为key重新赋值\n```js\nfunction printCoordinates({ left: x, top: y }) {",
  "es6\n### 循环\n```js\nfor (let {title, artist} of songs) {",
  "es6\n### 对象结构\n```js\nconst { id, ...detail } = song;",
  "es6\n## 扩展运算\n### 对象扩展\n#### 使用对象扩展\n```js\nconst options = {",
  "es6\n#### 不使用对象扩展\n```js\nconst options = Object.assign(",
  "es6\n### 数组扩展\n#### 使用数组扩展\n```js\nconst users = [",
  "es6\n#### 不使用数组扩展\n```js\nconst users = admins",
  "es6\n## 函数\n### 参数\n#### 参数默认值\n```js\nfunction greet (name = 'Jerry') {",
  "es6\n#### 余下的参数\n```js\nfunction fn(x, ...y) {",
  "es6\n#### 扩展\n```js\nfn(...[1, 2, 3])",
  "es6\n### 箭头函数\n#### 箭头函数\n```js\nsetTimeout(() => {",
  "es6\n#### 带参数\n```js\nreadFile('text.txt', (err, data) => {",
  "es6\n#### 隐式返回\n```js\nnumbers.map(n => n * 2)",
  "es6\n## 对象\n### 速记语法\n```js\nmodule.exports = { hello, bye }",
  "es6\n### 方法\n```js\nconst App = {",
  "es6\n### Getters 和 setters\n```js\nconst App = {",
  "es6\n### 计算属性名\n```js\nlet event = 'click'",
  "es6\n### 提取值\n```js\nconst fatherJS = { age: 57, name: \"Brendan Eich\" }",
  "es6\n## 模块\n### 导入\n```js\nimport 'helpers'",
  "es6\n### 导出\n```js\nexport default function () { ··· }",
  "es6\n## Generators\n### Generators\n```js\nfunction* idMaker () {",
  "es6\n### For..of 遍历\n```js\nfor (let i of iterable) {",
  "awk\n### 开始\n#### 从netstat命令中提取了如下信息作为用例\n```bash\n$ cat netstat.txt",
  "awk\n### 第一个例子\n其中单引号中的被**大括号**括着的就是`awk`的语句，注意，其只能被**单引号**包含。\n其中的`$1..$n`表示第几例。注：`$0`表示整个行。",
  "awk\n### 格式化输出\n`awk`的格式化输出，和`C`语言的`printf`没什么两样：\n```bash",
  "awk\n## 起步\n### 过滤记录\n#### 过滤条件为：**第3列**的值为`0` && **第6列**的值为`LISTEN`\n```bash\n$ awk '$3==0 && $6==\"LISTEN\" ' netstat.txt",
  "awk\n### 内建变量",
  "awk\n### 指定分隔符\n```bash\n$  awk  'BEGIN{FS=\":\"} {print $1,$3,$6}' /etc/passwd",
  "awk\n## 进阶\n### 字符串匹配\n```bash\n$ awk '$6 ~ /FIN/ || NR==1 {print NR,$4,$5,$6}' OFS=\"\\t\" netstat.txt",
  "awk\n### 折分文件\nawk拆分文件很简单，使用重定向就好了。下面这个例子，是按第6列分隔文件（`group by`，不同值分到不同的文件中），相当的简单（其中的`NR!=1`表示不处理表头）。\n```bash",
  "awk\n### 统计\n下面的命令计算所有的C文件，CPP文件和H文件的文件大小总和。\n```bash",
  "awk\n## 深入\n### awk脚本\n#### 运行前\n```bash\nBEGIN { 这里面放的是执行前的语句 }",
  "awk\n#### 运行中\n```bash\n{ 这里面放的是处理每一行时要执行的语句 }",
  "awk\n#### 运行后\n```bash\nEND {这里面放的是处理完所有的行后要执行的语句 }",
  "awk\n#### 案例\n假设有这么一个文件（学生成绩表）：\n```bash",
  "awk\n### 环境变量\n即然说到了脚本，我们来看看怎么和环境变量交互：（使用`-v`参数和`ENVIRON`，使用`ENVIRON`的环境变量需要`export`）\n```bash",
  "awk\n### 几个小例子\n```bash\n#从file文件中找出长度大于80的行",
  "regex\n### 字符",
  "regex\n### 字符类",
  "regex\n### 预定义字符类",
  "regex\n### 边界匹配器",
  "regex\n### Greedy 数量词\n匹配优先，优先匹配最大长度，匹配尽可能多的内容",
  "regex\n### Reluctant 数量词\n忽略优先，尽可能匹配最少内容，满足下限即成功",
  "regex\n### Possessive 数量词\n占有优先，优先匹配最大长度，放弃备用状态",
  "regex\n### Logical 运算符",
  "regex\n###  特殊构造（非捕获）",
  "regex\n###  环视结构（非捕获）\n环视结构，包括肯定型和否定型，顺序环视和逆序环视，它们只是简单的测试，其中表达式能否在当前的位置匹配后面的内容（顺序），或者前面的内容（逆序），并不改变当前位置。",
  "regex\n## 常见需求\n### 案例\n// TODO",
  "springCloud\n### 项目结构\n项目在一个工程中，通过`module`进行组装。\n```",
  "springCloud\n### 项目结构说明",
  "redis\n### 启动\n```bash\n./redis-server                      # 启动服务",
  "redis\n#### 以配置文件方式启动\n```bash\n./redis-server redis.conf &",
  "redis\n### 登录\n```bash\n./redis-cli           # 登录",
  "redis\n#### 客户端参数",
  "redis\n## 操作\n### string（字符串）",
  "redis\n### list（列表）",
  "redis\n### Client­/Server",
  "redis\n### set（集合）\n显然，`set`会忽略重复元素",
  "redis\n### database（数据库）",
  "redis\n### Script（脚本）\nredis支持`Lua`脚本",
  "redis\n### Hash（哈希表）",
  "redis\n### SortedSet（有序集合）",
  "golang\n### Credits\n大部分例子来源于[A Tour of Go](http://tour.golang.org/), 是`Go`非常优秀的入门教程，如果你是新手，建议你先看看这个教程。\n### 简述\n- 命令式语言\n- 静态类型",
  "golang\n### Hello World\nFile `hello.go`:\n```go",
  "golang\n## 操作符\n### 算术运算",
  "golang\n### 对比",
  "golang\n### 逻辑运算",
  "golang\n### 其他",
  "golang\n## 变量声明\n类型在标识符之后\n```go",
  "golang\n## 函数\n### 函数定义\n#### 一个简单的函数\n```go\nfunc functionName() {}",
  "golang\n#### 带参数函数（同样的，类型在标识符之后）\n```go\nfunc functionName(param1 string, param2 int) {}",
  "golang\n#### 同类型的多个参数\n```go\nfunc functionName(param1, param2 int) {}",
  "golang\n#### 返回值类型声明\n```go\nfunc functionName() int {",
  "golang\n#### 返回多个参数\n```go\nfunc returnMulti() (int, string) {",
  "golang\n#### 只需通过return返回多个命名结果\n```go\nfunc returnMulti2() (n int, s string) {",
  "golang\n### 函数作为值和闭包\n```go\nfunc main() {",
  "golang\n#### 闭包，字面作用域：定义函数时，函数可以访问作用域内的值\n```go\nfunc scope() func() int{",
  "golang\n#### 闭包\n```go\nfunc outer() (func() int, int) {",
  "golang\n### 可变参数函数\n```go\nfunc main() {",
  "golang\n#### 通过在最后一个参数的类型名称前使用`...`，接受零个或多个参数。\n```go\nfunc adder(args ...int) int {",
  "golang\n## 类型\n### 内置类型\n```go\nbool",
  "golang\n### 结构 Struct\ngo没有类`class`，只有结构`struct`，结构可以拥有方法。struct 是一种类型，也是成员变量的集合。\n```go",
  "golang\n#### **匿名struct:**，比`map[string]interface{}`更轻量和安全\n```go\npoint := struct {",
  "golang\n### 指针\n```go\np := Vertex{1, 2}  // p 是一个 Vertex",
  "golang\n#### 指向 Vertex 的指针类型为 *Vertex\n```go\nvar s *Vertex = new(Vertex) // 创建一个指向Vertex实例的指针",
  "golang\n### 类型转换\n```go\nvar i int = 42",
  "golang\n## Packages\n- 每个源文件顶部声明包\n- 可执行文件位于包`main`中",
  "golang\n## 控制结构\n### If\n```go\nfunc main() {",
  "golang\n### Loops\n只有`for`，没有`while`和`until`\n```go",
  "golang\n### Switch\n```go\nswitch operatingSystem {",
  "golang\n#### 与for和if一样，在switch值之前可以有一个赋值语句\n```go\nswitch os := runtime.GOOS; os {",
  "golang\n#### 可以使用对比\n```go\nnumber := 42",
  "golang\n#### 多个case可用逗号分割\n```go\nvar char byte = '?'",
  "golang\n## 集合\n### 数组\n```go\nvar a [10]int // 声明长度为10的数组，长度是类型的一部分",
  "golang\n### 切片\n```go\nvar a []int                      // 声明切片 - 和数组类似，但不指定长度",
  "golang\n### 操作数组和切片\n`len(a)` 返回数组/切片的长度，这是一个内置函数，而不是数组上的属性/方法。\n```go",
  "golang\n### Maps\n```go\nvar m map[string]int",
  "golang\n## 多态\n### 接口\n#### 接口声明\n```go\ntype Awesomizer interface {",
  "golang\n#### 类型不声明实现接口\n```go\ntype Foo struct {}",
  "golang\n#### 如果类型实现所有必需的方法，则它们隐式满足接口\n```go\nfunc (foo Foo) Awesomize() string {",
  "golang\n### 嵌入\nGo中没有`子类`。 而是有`接口`和`结构`嵌入。\n```go",
  "golang\n## 并发\n### Goroutines\n`Goroutines`是轻量级线程（由Go而不是OS管理）。 `go f(a, b)`启动一个新的goroutine，该例程将运行`f`（`f`是一个函数）。\n```go",
  "golang\n### Channels\n#### 非阻塞通道，发送和接收动作是同时发生的，如果没有接收者，发送会一直阻塞\n```go\nch := make(chan int) // 创建一个类型为int的通道",
  "golang\n#### 缓冲通道，如果已写入小于<buffer size>的未读值，则写入不会阻塞。\n```go\nch := make(chan int, 100)",
  "golang\n#### 关闭通道（只有发送者应该关闭）\n```go\nclose(ch)",
  "golang\n#### 从通道读取并测试是否已关闭\n```go\nv, ok := <-ch",
  "golang\n#### 读取通道直至关闭\n```go\nfor i := range ch {",
  "golang\n#### 尝试多种通道操作，如果没有柱塞，则执行相应操作\n```go\nfunc doStuff(channelOut, channelIn chan int) {",
  "golang\n### Channel Axioms\n#### 发送到nil通道将永远阻塞\n```go\nvar c chan string",
  "golang\n#### 接收自nil通道将永远阻塞\n```go\nvar c chan string",
  "golang\n#### 发送到已关闭通道触发panic\n```go\nvar c = make(chan string, 1)",
  "golang\n#### 来自关闭通道的接收立即返回零值\n```go\nvar c = make(chan int, 2)",
  "golang\n## 杂项\n### 错误\n没有异常处理，可能会产生错误的函数只需声明类型为Error的附加返回值即可。 这是`Error`的接口：\n```go",
  "golang\n### 打印\n```go\nfmt.Println(\"Hello, 你好, नमस्ते, Привет, ᎣᏏᏲ\") // 基本打印，结尾换行",
  "golang\n### 反射 - 类型 Switch\n类型switch类似于常规switch语句，但是类型switch中的case指定类型（不是值），并将这些类型与给定接口的类型进行比较。\n```go",
  "golang\n### HTTP Server\n```go\npackage main",
  "RESTful\n## URL设计\n### 动词 + 宾语\nRESTful的核心思想就是，客户端发出的数据操作指令都是\"动词 + 宾语\"的结构。比如，`GET /articles`这个命令，`GET`是动词，`/articles`是宾语。",
  "RESTful\n### 动词的覆盖\n有些客户端只能使用`GET`和`POST`这两种方法，服务器必须接受`POST`模拟其他三个方法（`PUT`、`PATCH`、`DELETE`）。\n通过`X-HTTP-Method-Override`属性，告诉服务器覆盖的是哪种请求。",
  "RESTful\n### 宾语必须是名词\n宾语显然是名称，它是API的URL，是HTTP动词作用的对象。比如，`/articles`这个URL就是正确的，而下面的URL是错误的:\n- /getAllCars",
  "RESTful\n### 复数 URL\n既然URL是名词，那么应该使用复数，还是单数？\n这没有统一的规定，但是常见的操作是读取一个集合，比如`GET /articles`（读取所有文章），这里明显应该是复数。",
  "RESTful\n### 避免多级 URL\n常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。\n```nginx",
  "RESTful\n## 状态码\n### 状态码必须精确\n客户端的每一次请求，服务器都必须给出回应。回应包括 **HTTP状态码**和**数据**两部分。\nHTTP状态码就是一个三位数，分成五个类别。",
  "RESTful\n### 2xx 状态码\n`200`状态码表示操作成功，但是不同的方法可以返回更精确的状态码。",
  "RESTful\n### 3xx 状态码\n#### 应用级别，浏览器会直接跳转",
  "RESTful\n#### API级别",
  "RESTful\n### 4xx 状态码\n`4xx`状态码表示客户端错误，主要有下面几种。",
  "RESTful\n### 5xx 状态码\n`5xx`表示服务端错误。一般来说，API 不会向用户透露服务器的详细信息。",
  "RESTful\n## 服务器响应\n### 响应数据格式\nAPI 返回的数据格式，应该是一个`JSON`对象，所以：\n- 服务器响应时HTTP头`Content-Type`属性设为`application/json`",
  "RESTful\n### 错误时，不返回200状态码\n有一种**不恰当**的做法是，即使发生错误，也返回200状态码，把错误信息放在数据体里面：\n```nginx",
  "RESTful\n### 提供链接\nAPI 的使用者未必知道，URL 是怎么设计的。一个解决方法就是，在回应中，给出相关链接，便于下一步操作。这样的话，用户只要记住一个 URL，就可以发现其他的 URL。这种方法叫做`HATEOAS`。\n举例来说，GitHub 的 API 都在 [api.github.com](api.github.com) 这个域名。访问它，就可以得到其他 URL。",
  "RESTful\n## RESTful 成熟度\n### Richardson 成熟度模型\n[RESTful Web APIs](https://book.douban.com/subject/22139962/)和[RESTful Web Services](https://book.douban.com/subject/2054201/)的作者伦纳德 · 理查德森（Leonard Richardson），曾提出过一个衡量**服务有多么 REST**的 *Richardson 成熟度模型*（[Richardson Maturity Model](https://martinfowler.com/articles/richardsonMaturityModel.html)，RMM）。这个模型的一个用处是，方便那些原本不使用 REST 的服务，能够逐步导入 REST。\nRichardson 将服务接口按照“REST 的程度”，从低到高分为 0 至 3 共 4 级：",
  "RESTful\n### 第 0 级成熟度：The Swamp of Plain Old XML\n医院开放了一个 `/appointmentService` 的 Web API，传入日期、医生姓名作为参数，就可以得到该时间段、该医生的空闲时间。\n```js",
  "RESTful\n### 第 1 级成熟度：Resources\n实际上你可以发现，第 0 级是 RPC 的风格，所以如果需求永远不会变化，也不会增加，那它完全可以良好地工作下去。但是，如果你不想为预约医生之外的其他操作、为获取空闲时间之外的其他信息去编写额外的方法，或者改动现有方法的接口，那就应该考虑一下如何使用 REST 来抽象资源。\n通往 REST 的第一步是引入资源的概念，在 API 中最基本的体现，就是它会围绕着资源而不是过程来设计服务。说得直白一点，你可以理解为服务的 `Endpoint` 应该是一个**名词**而不是动词。此外，每次请求中都应包含资源 ID，所有操作均通过资源 ID 来进行。",
  "RESTful\n### 第 2 级成熟度：HTTP Verbs\n前面说到，第 1 级中遗留的这三个问题，都可以靠引入统一接口来解决，而 HTTP 协议的标准方法便是最常接触到的统一接口。\nHTTP 协议的标准方法是经过精心设计的，它几乎涵盖了资源可能遇到的所有操作场景（这其实更取决于架构师的抽象能力）。",
  "RESTful\n### 第 3 级成熟度：Hypermedia Controls\n或许你第一眼看到这个问题会说，这当然是程序写的啊，我为什么会问这么奇怪的问题。但问题是，REST 并不认同这种已烙在程序员脑海中许久的想法。\nRMM 中的第 3 级成熟度 `Hypermedia Controls`、Fielding 论文中的 `HATEOAS` 和现在提得比较多的`超文本驱动`，其实都是希望能达到这样一种效果：**除了第一个请求是由你在浏览器地址栏输入的信息所驱动的之外，其他的请求都应该能够自己描述清楚后续可能发生的状态转移，由超文本自身来驱动。**",
  "RESTful\n## REST 的不足与争议\n### `争议一` 面向资源只适合做 CRUD\n面向资源的编程思想只适合做 CRUD，只有面向过程、面向对象编程才能处理真正复杂的业务逻辑。原因也很简单，HTTP 的 4 个最基础的命令 POST、GET、PUT 和 DELETE，很容易让人联想到 CRUD 操作。\nREST 涵盖的范围当然远不止于此。不过要说 POST、GET、PUT 和 DELETE 对应于 CRUD，其实也没什么不对，只是我们必须泛化地去理解这个 CRUD：它们涵盖了信息在客户端与服务端之间流动的几种主要方式（比如 POST、GET、PUT 等标准方法），所有基于网络的操作逻辑，都可以通过解决“信息在服务端与客户端之间如何流动”这个问题来理解，有的场景里比较直观，而另一些场景中可能比较抽象。",
  "RESTful\n### `争议二` REST 与 HTTP 完全绑定，不适用于要求高性能传输\n其实，我在很大程度上赞同这个观点，但我并不认为这是 REST 的缺陷，因为锤子不能当扳手用，并不是锤子的质量有问题。\n面向资源编程与协议无关，但是 REST（特指 Fielding 论文中所定义的 REST，而不是泛指面向资源的思想）的确依赖着 HTTP 协议的标准方法、状态码和协议头等各个方面。",
  "RESTful\n### `争议三` REST 不利于事务支持\n其实，这个问题首先要看我们怎么去理解**事务（Transaction）**这个概念了。\n- 如果“事务”指的是数据库那种狭义的刚性 ACID 事务，那分布式系统本身跟它之间就是有矛盾的（CAP 不可兼得）。这是分布式的问题，而不是 REST 的问题。",
  "RESTful\n### `争议四` REST 没有传输可靠性支持\n是的，REST 并没有提供对传输可靠性的支持。在 HTTP 中，你发送出去一个请求，通常会收到一个与之相对的响应，比如 `HTTP/1.1 200 OK` 或者 `HTTP/1.1 404 Not Found` 等。但是，如果你没有收到任何响应，那就无法确定消息到底是没有发送出去，还是没有从服务端返回回来。这其中的关键差别，是服务端到底是否被触发了某些处理？\n应对传输可靠性最简单粗暴的做法，就是把消息再重发一遍。这种简单处理能够成立的前提，是服务具有**幂等性（Idempotency）**，也就是说服务被重复执行多次的效果与执行一次是相等的。",
  "RESTful\n### `争议五` REST 缺乏对资源进行“部分”和“批量”的处理能力\n这个观点我是认同的，而且我认为这很可能是未来面向资源的思想和 API 设计风格的发展方向。\nREST 开创了面向资源的服务风格，却肯定不完美。以 HTTP 协议为基础，虽然给 REST 带来了极大的便捷（不需要额外协议，不需要重复解决一堆基础网络问题，等等），但也成了束缚 REST 的无形牢笼。",
  "RESTful\n#### 第一种束缚，就是缺少对资源的“部分”操作的支持。\n有些时候，我们只是想获得某个用户的姓名，RPC 风格中可以设计一个`getUsernameById`的服务，返回一个字符串。尽管这种服务的通用性实在称不上“设计”二字，但确实可以工作。而要是采用 REST 风格的话，你需要向服务端请求整个用户对象，然后丢弃掉返回结果中的其他属性，这就是一种请求冗余（Overfetching）。\nREST 的应对手段是，通过位于中间节点或客户端缓存来缓解。但这治标不治本，因为这个问题的根源在于，HTTP 协议对请求资源完全没有结构化的描述能力（但有的是非结构化的部分内容获取能力，也就是今天多用于端点续传的Range Header），所以返回资源的哪些内容、以什么数据类型返回等等，都不可能得到协议层面的支持。如果要实现这种能力，你就只能自己在 GET 方法的 Endpoint 上设计各种参数。\n#### 而与此相对的缺陷，也是 HTTP 协议对 REST 的第二种束缚，是对资源的“批量”操作的支持。\n有时候，我们不得不为此而专门设计一些抽象的资源才能应对。\n比如，我们要把某个用户的昵称增加一个“VIP”前缀，那提交一个 PUT 请求修改这个用户的昵称就可以了。但如果我们要给 1000 个用户的昵称加“VIP”前缀时，就不得不先创建一个（比如名为“VIP-Modify-Task”）任务资源，把 1000 个用户的 ID 交给这个任务，最后驱动任务进入执行状态（如果真去调用 1000 次 PUT，等浏览器回应我们 HTTP/1.1 429 Too Many Requests 的时候，老板就要发飙了）。",
  "java8\n### Lambda 表达式\n```java\n(int a) -> a * 2; // 求a乘以2后的值",
  "java8\n#### 如果lambda里面的代码块超过1行，可以配合使用 `{ }` 加 `return`来处理\n```java\n(x, y) -> {",
  "java8\n#### 一个lamdba表达式必须依赖一个具体的功能接口而存在\n```java\ninterface MyMath {",
  "java8\n#### 下面所有的测试都是用到这个`list` :\n```java\nList<String> list = [Bohr, Darwin, Galilei, Tesla, Einstein, Newton]",
  "java8\n### Collections 集合\n#### **sort** `sort(list, comparator)`\n```java\n// 正序",
  "java8\n#### **removeIf**\n```java\nlist.removeIf(w -> w.length() < 6);",
  "java8\n#### **merge** `merge(key, value, remappingFunction)`\n```java\nMap<String, String> names = new HashMap<>();",
  "java8\n### 方法引用 `Class::staticMethod`\n允许引用类方法或者构造函数，引用时候是不执行的\n```java",
  "java8\n### Optional\n在Java, 通常使用`null`表示没有结果，但是如果不检查的话很容易出现`NullPointerException`.\n```java",
  "java8\n## Streams 流式处理\n和`collections`类似, 但有所不同:\n- 不能储存数据",
  "java8\n#### **创建一个stream**\n```java\nStream<Integer> stream = Stream.of(1, 2, 3, 5, 7, 11);",
  "java8\n#### **集合结果集**\n```java\n//返回成一个数组 (::new 是构造函数的引用)",
  "java8\n#### **map** `map(mapper)` 对每个元素进行类型转换\n```java\n// 对每个元素使用 \"toLowerCase\" 处理",
  "java8\n#### **filter** `filter(predicate)` 过滤处理，只保留匹配到的元素\n```java\n// 过掉保留 \"E\" 开头的元素",
  "java8\n#### **reduce** 汇聚处理成为单一返回结果\n```java\nString reduced = stream",
  "java8\n#### **limit** `limit(maxSize)` 保留前`maxSize`个元素\n```java\nres = stream.limit(3);",
  "java8\n#### **skip** 忽略掉前`n`个元素\n```java\nres = strem.skip(2); // 忽略 Bohr 和 Darwin",
  "java8\n#### **distinct** 去重\n```java\nres = Stream.of(1,0,0,1,0,1).distinct();",
  "java8\n#### **sorted** 排序 (必须使用 *Comparable* 接口)\n```java\nres = stream.sorted();",
  "java8\n#### **allMatch** 全匹配\n```java\n// 检查是否每个元素包含“e“",
  "java8\n#### **parallel** 返回一个并行的stream\n#### **findAny** 在并行流上findFirst执行更快\n### 原始类型的 Streams\n原始类型的stream自动封装是低效的 (例如 Stream<Integer>) ，因为它需要对每个元素进行大量拆箱和装箱. 所以最好使用 `IntStream`, `DoubleStream`, 等等.\n#### **初始化**\n```java\nIntStream stream = IntStream.of(1, 2, 3, 5, 7);",
  "java8\n### Grouping 结果集\n#### **Collectors.groupingBy**\n```java\n// 通过长度分组",
  "java8\n#### **Collectors.toSet**\n```java\n// 和之前一样但是使用的是Set",
  "java8\n#### **Collectors.counting** 计算个数\n#### **Collectors.summing__** 计算累加 `summingInt`, `summingLong`, `summingDouble`\n#### **Collectors.averaging__** 计算平均数 `averagingInt`, `averagingLong`, ...\n```java\nCollectors.averagingInt(String::length)",
  "java8\n### 并行 Streams\n#### **创建并行处理stream**\n```java\nStream<String> parStream = list.parallelStream();",
  "java8\n#### **unordered** 能提高计算 `limit`，`distinct`的速度\n```java\nstream.parallelStream().unordered().distinct();",
  "java8\n### 注意引用推测限制\n```java\ninterface Pair<A, B> {",
  "java8\n## LocalDate\n### 简介\n在JAVA中，常用的处理日期和时间的类主要有`Date`，`Calendar`，而在JDK1.8中，新增了`LocalDate`、`LocalTime`、`LocalDateTime` 类的实例是不可变的对象，分别表示使用ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。\n### API\n#### **now()** 静态方法，根据当前时间创建对象\n```java\nLocalDate.now();",
  "java8\n#### **of()** 静态方法，根据指定时间创建对象\n```java\nLocalDate.of(2020, 12, 2);",
  "java8\n#### **plus, minus** 向当前时间添加指定长度时间\n```java\nLocalDate.now().plusDays(30);",
  "java8\n#### **isBefore、isAfter** 比较两个时间\n```java\nLocalDate.now().isAfter(LocalDate.now().minusDays(1))",
  "java8\n### Instant 时间戳\n用于`时间戳`的运算。它是以Unix元年(传统的设定为UTC时区1970年1月1日午夜时分)开始所经历的描述进行运算。\n```java",
  "java8\n### Duration 和 Period\n#### **Duration:** 用于计算两个“时间”间隔\n```java\nInstant now = Instant.now();",
  "java8\n#### **Period:** 用于计算两个“日期”间隔\n```java\nLocalDate now = LocalDate.now();",
  "java8\n### 日期操作\n- **TemporalAdjuster**: 时间校正器。\n- **TemporalAdjusters**: 该类通过静态方法提供了大量的常用 TemporalAdjuster 的实现。",
  "java8\n#### 本月第一天\n```java\nLocalDateTime firstday = date.with(TemporalAdjusters.firstDayOfMonth());",
  "java8\n#### 本月最后一天\n```java\nLocalDateTime lastDay = date.with(TemporalAdjusters.lastDayOfMonth());",
  "java8\n#### 上个月最后一天\n```java\nLocalDateTime next_lastday = date.with(TemporalAdjusters.lastDayOfMonth());",
  "java8\n#### 下个周日\n```java\nLocalDate nextSunday = LocalDate.now().with(TemporalAdjusters.next(DayOfWeek.SUNDAY));",
  "java8\n#### 计算两个日期相差的月份数\n```java\nlong betweenMONTHS = ChronoUnit.MONTHS.between(beforeDate, afterDate);",
  "java8\n### 解析与格式化\n#### 日期格式化成字符串\n```java\nLocalDate now = LocalDate.now();",
  "java8\n#### 字符串解析成时间\n```java\nSystem.out.println(LocalDate.parse(\"2020/12/01\", DateTimeFormatter.ofPattern(\"yyyy/MM/dd\")));",
  "数据密集型应用\n## 可靠性、可扩展性、可维护性\n### 可靠性\n#### 典型期望\n- 应用程序表现出用户所期望的功能。\n- 允许用户犯错，允许用户以出乎意料的方式使用软件。",
  "数据密集型应用\n#### 可以恢复的故障种类\n- 硬件故障\n- 软件错误",
  "数据密集型应用\n### 可扩展性\n可扩展性（Scalability）是用来描述系统应对负载增长能力的术语。\n#### 描述负载\n负载可以用一些称为负载参数（load parameters）的数字来描述。参数的最佳选择取决于系统架构，它可能是每秒向Web服务器发出的请求、数据库中的读写比率、聊天室中同时活跃的用户数量、缓存命中率或其他东西。除此之外，也许平均情况对你很重要，也许你的瓶颈是少数极端场景。\n#### `案例`推特\n用户时间线上展示关注的用户动态，有两种常见方案：\n- 发帖，粉丝上线后关联查询所有关注用户动态，按时间序合并",
  "数据密集型应用\n#### 描述性能\n一旦系统的负载被描述好，就可以研究当负载增加会发生什么：\n- 增加负载参数并保持系统资源（CPU、内存、网络带宽等）不变时，系统性能将受到什么影响？",
  "数据密集型应用\n#### 应对负载的方法\n适应某个级别负载的架构不太可能应付10倍于此的负载。如果你正在开发一个快速增长的服务，那么每次负载发生数量级的增长时，你可能都需要重新考虑架构。\n- **纵向扩展**（scaling up），垂直扩展（vertical scaling），转向更强大的机器",
  "数据密集型应用\n### 可维护性\n软件的大部分开销并不在最初的开发阶段，而是在持续的维护阶段，一般包括：\n- 修复漏洞",
  "数据密集型应用\n## 数据模型与查询语言\n应用每个层都通过提供一个明确的数据模型来隐藏更低层次中的复杂性。这些抽象允许不同的人群有效地协作（例如数据库厂商的工程师和使用数据库的应用程序开发人员）。\n数据模型对上层软件的功能（能做什么，不能做什么）有着至深的影响，所以选择一个适合的数据模型是非常重要的。\n### 关系模型与文档模型\n现在最著名的数据模型可能是SQL。它基于Edgar Codd在1970年提出的关系模型：**数据被组织成关系（SQL中称作表），其中每个关系是元组（SQL中称作行)的无序集合。**\n多年来，在数据存储和查询方面存在着许多相互竞争的方法。在20世纪70年代和80年代初，网络模型和分层模型曾是主要的选择，但关系模型随后占据了主导地位。\n#### NoSQL的诞生\nNoSQL被追溯性地重新解释为不仅是SQL（Not Only SQL）。采用NoSQL数据库的背后有几个驱动因素，其中包括：\n- 需要比关系数据库更好的**可扩展性**，包括非常大的数据集或非常高的写入**吞吐量**",
  "数据密集型应用\n#### 对象关系不匹配\n目前大多数应用程序开发都使用面向对象的编程语言来开发，这导致了对SQL数据模型的普遍批评：如果数据存储在关系表中，那么需要一个笨拙的转换层，处于应用程序代码中的对象和表，行，列的数据库模型之间。**模型之间的不连贯有时被称为阻抗不匹配（impedance mismatch）**\n#### 数据模型选择\n于高度相联的数据，选用文档模型是糟糕的，选用关系模型是可接受的，而选用图形模型是最自然的\n#### 文档模型中的架构灵活性\n文档数据库有时称为无模式（schemaless），但这具有误导性，因为读取数据的代码通常假定某种结构——即存在隐式模式，但不由数据库强制执行。一个更精确的术语是**读时模式（schema-on-read）**，相应的是**写时模式（schema-on-write）**。\n### 数据查询语言\nSQL是一种声明式查询语言，而IMS和CODASYL使用命令式代码来查询数据库。\n#### Web上的声明式查询\n在Web浏览器中，使用声明式CSS样式比使用JavaScript命令式地操作样式要好得多。类似地，在数据库中，使用像SQL这样的声明式查询语言比使用命令式查询API要好得多。\n#### MapReduce查询\nMapReduce是一个由Google推广的编程模型，用于在多台机器上批量处理大规模的数据。一些NoSQL数据存储（包括MongoDB和CouchDB）支持有限形式的MapReduce，作为在多个文档中执行只读查询的机制。\nMapReduce既不是一个声明式的查询语言，也不是一个完全命令式的查询API，而是处于两者之间：查询的逻辑用代码片断来表示，这些代码片段会被处理框架重复性调用。它基于 map （也称为 collect ）和 reduce （也称为 fold 或 inject ）函数，两个函数存在于许多函数式编程语言中。\n### 图数据模型\n随着数据之间的连接变得更加复杂，将数据建模为图形显得更加自然。\n一个图由两种对象组成：",
  "数据密集型应用\n#### 属性图\n在属性图模型中，每个**顶点（vertex）**包括：\n- 唯一的标识符",
  "数据密集型应用\n### 三元组存储和SPARQL\n三元组存储中，所有信息都以非常简单的三部分表示形式存储（主语，谓语，宾语）。\n三元组的**主语**相当于图中的一个**顶点**。而**宾语**是下面两者之一：",
  "数据密集型应用\n## 存储与检索\n### 驱动数据库的数据结构\n世界上最简单的数据库可以用两个Bash函数实现：\n```bash",
  "数据密集型应用\n### 哈希索引\n最简单的索引策略就是：保留一个内存中的哈希映射，其中每个键都映射到一个数据文件中的字节偏移量，指明了可以找到对应值的位置。\n#### 避免最终用完磁盘空间\n一种好的解决方案是：\n- 将日志分为特定大小的段",
  "数据密集型应用\n#### 实践中的问题\n- 文件格式\n- CSV不是日志的最佳格式。使用二进制格式更快，更简单，首先以字节为单位对字符串的长度进行编码，然后使用原始字符串（不需要转义）。",
  "数据密集型应用\n#### 哈希表索引局限性\n- 散列表必须能放进内存\n- 范围查询效率不高\n### SSTables和LSM树\n现在对段文件的格式做一个简单的改变：要求键值对的序列**按键排序**。\n这个格式称为排序字符串表（Sorted String Table），简称SSTable。我们还要求每个键只在每个合并的段文件中出现一次（压缩过程已经保证），与散列比有以下优势：",
  "数据密集型应用\n### 构建和维护SSTables\n- 写入时，将其添加到内存中的平衡树数据结构（例如，红黑树）。这个内存树有时被称为**内存表**（memtable）。\n- 当内存表大于某个**阈值**（通常为几兆字节）时，将其作为SSTable文件**写入磁盘**。新的SSTable文件成为数据库的最新部分。当SSTable被写入磁盘时，写入可以继续到一个新的内存表实例。",
  "数据密集型应用\n### 用SSTables制作LSM树\n**日志结构合并树**（或LSM树）的基础上，建立在以前的工作上日志结构的文件系统。基于这种合并和压缩排序文件原理的存储引擎通常被称为LSM存储引擎。\n`Lucene`是`Elasticsearch`和`Solr`使用的一种全文搜索的索引引擎，它使用类似的方法来存储它的词典。全文索引比键值索引复杂得多，但是基于类似的想法：在搜索查询中给出一个单词，找到提及单词的所有文档（网页，产品描述等）。在Lucene中，从术语到发布列表的这种映射保存在SSTable类的有序文件中，根据需要在后台合并。\n### 性能优化\n查找不存在的键时，必须遍历内存表和所有文件段，为了优化这种访问，存储引擎通常使用额外的Bloom过滤器。\n还有不同的策略来确定SSTables如何被压缩和合并的顺序和时间。\n### B树\n在几乎所有的关系数据库中，它们仍然是标准的索引实现，许多非关系数据库也使用它们。\nB树将数据库分解成固定大小的块或页面，传统上大小为4KB（有时会更大），并且一次只能读取或写入一个页面。",
  "数据密集型应用\n#### 更新数据\n- 搜索包含该键的叶页\n- 更改该页中的值",
  "beautifulCode\n### max(a, b)\n```js\n(b & (a - b >> 31) | a & ~(a - b >> 31))",
  "beautifulCode\n### html随机颜色边框\n```js\n// 命令行中 $$ 等同于 document.querySelectorAll",
  "beautifulCode\n### 评分\n```js\nlet rating = 3;",
  "beautifulCode\n### 值交换\n```js\na = a ^ b",
  "beautifulCode\n### 正则表达式简单解析器",
  "Lisp\n## 构造过程抽象\n程序设计的基本元素\n- 基本表达形式",
  "Lisp\n### 表达式\n```\n(+ 3 5 )",
  "Lisp\n### 命名和环境\n`define`定义变量\n```",
  "Lisp\n### 组合式的求值\n- 求值各个子表达式\n- 从最左表达式的值开始计算",
  "Lisp\n### 复合过程\n**过程定义**为复合操作命名\n```",
  "Lisp\n### 过程应用的代换模型\n树形积累的计算过程称为**代换模型**，帮助领会调用过程，并不是解释器的实际工作方式。\n**正则序求值**，即*完全展开后归约*，先进行代换展开，不先局部计算",
  "Lisp\n### 条件表达式和谓词\n`cond`表示条件\n```",
  "Lisp\n### 牛顿法求平方根\n计算机科学里，更关心行动性的描述。牛顿法采用逐步逼近法，对`x`的平方根有一个猜测`y`，令`y = (x + x/y) / 2`，然后判断`y`够不够接近。\n```",
  "Lisp\n### 过程作为黑箱抽象\n#### **局部名** 局部变量名不影响过程和结果\n#### **内部定义和块结构**\n将所有辅助过程定义放到内部\n```",
  "Lisp\n## 过程与所产生的计算\n### 线性的递归和迭代\n阶乘的定义：\n```",
  "Lisp\n### 树形递归\n另一种常见到的计算模式是`树形递归`，以**斐波那契**数序列的计算为例：\n```",
  "Lisp\n### 最大公约数\n找到两个整数的做大公约数(GCD)的一种方法是对她们做因数分解，并找出公共因子，但存在一种更高效的算法（欧几里得算法）：\n*如果`r`是`a`除以`b`的余数，那么`a`和`b`的GCD正好是`b`和`r`的GCD*，即：",
  "Lisp\n## 用高阶函数做抽象\n### 过程作为参数\n序列求和：\n```",
  "Lisp\n### 用lambda构造过程\n`lambda`和`define`使用同样的方式创建过程，但不为过程创建名字：\n```",
  "Lisp\n#### **用`let`创建局部变量**\n```\n(let ((<var1> <exp1>)",
  "markdown\n### 标题\n```markdown\n# 一级标题",
  "markdown\n### 强调\n```markdown\n*斜体*",
  "markdown\n### 列表\n```markdown\n* Item 1",
  "markdown\n### 链接\n```markdown\n[百度](https://www.baidu.com)",
  "markdown\n### 图片\n```markdown\n![Image alt text](/path/to/img.jpg)",
  "markdown\n### 代码\n```markdown\n4空格缩进",
  "markdown\n### 区块引用\n```markdown\n> 这是",
  "markdown\n### 水平线\n```markdown\n----",
  "markdown\n### 表格\n```markdown",
  "mysql\n### 登录\n```bash\nmysql -u [username] -p;",
  "mysql\n### 浏览\n```sql\nSHOW DATABASES;",
  "mysql\n### 查询 / SELECT\n```sql\nSELECT * FROM table;",
  "mysql\n### 连接查询\n```sql\nSELECT ... FROM t1 JOIN t2 ON t1.id1 = t2.id2 WHERE condition;",
  "mysql\n### 查询条件\n```sql\nfield1 = value1",
  "mysql\n### 创建/打开/删除/修改 数据库\n```sql\nCREATE DATABASE DatabaseName;",
  "mysql\n### 备份数据库\n// TODO\n```bash",
  "mysql\n### 恢复数据库\n```bash\nmysql - u Username -p DatabaseName < databasename_backup.sql;",
  "mysql\n### 异常关闭后修复数据库\n// TODO\n```bash",
  "mysql\n### 插入 / INSERT\n```sql\nINSERT INTO table1 (field1, field2) VALUES (value1, value2);",
  "mysql\n### 删除 / DELETE\n```sql\nDELETE FROM table1 / TRUNCATE table1",
  "mysql\n### 更新 / UPDATE\n```sql\nUPDATE table1 SET field1=new_value1 WHERE condition;",
  "mysql\n### 新建/删除/修改 表\n#### 新建 / CREATE\n```sql\nCREATE TABLE table (field1 type1, field2 type2);",
  "mysql\n#### 删除 - DROP\n```sql\nDROP TABLE table;",
  "mysql\n#### 修改 - ALTER\n```sql\nALTER TABLE table MODIFY field1 type1",
  "mysql\n#### 修改默认排序\n```sql\nALTER TABLE table MODIFY field1 type1 FIRST",
  "mysql\n### 键\n```sql\nCREATE TABLE table (..., PRIMARY KEY (field1, field2))",
  "mysql\n### 用户和授权\n```sql\nCREATE USER 'user'@'localhost';",
  "mysql\n### 主要数据类型\n```sql\nTINYINT (1o: -217+128)",
  "mysql\n### 重置root账户密码\n```bash\n$ /etc/init.d/mysql stop",
  "bash\n### 示例\n```bash\n#!/usr/bin/env bash",
  "bash\n### 变量\n```bash\nNAME=\"John\"",
  "bash\n### 字符串引号\n```bash\nNAME=\"John\"",
  "bash\n### Shell执行\n```bash\necho \"I'm in $(pwd)\"",
  "bash\n### 条件执行\n```bash\ngit commit && git push",
  "bash\n### 函数\n```bash\nget_name() {",
  "bash\n### 条件判断\n```bash\nif [[ -z \"$string\" ]]; then",
  "bash\n### Strict 模式\n```bash\nset -euo pipefail",
  "bash\n### 花括号展开\n```bash\necho {A,B}.js",
  "bash\n## 参数扩展\n### 基本使用\n```bash\nname=\"John\"",
  "bash\n### 替换\n`%rule`删除`rule`到结束匹配的内容，`#rule`删除开始到`rule`匹配的内容，即`%`删除后缀、`#`删除前缀。\n另外，默认为最小匹配，叠字`%%`、`##`为贪婪匹配。",
  "bash\n### 注释\n```bash\n# Single line comment",
  "bash\n### 子串",
  "bash\n### 长度",
  "bash\n### 操作\n```bash\nSTR=\"HELLO WORLD!\"",
  "bash\n### 默认值",
  "bash\n## 循环\n### 基本循环\n```bash\nfor i in /etc/rc*; do",
  "bash\n### C-like 循环\n```bash\nfor ((i = 0 ; i < 100 ; i++)); do",
  "bash\n### 范围\n```bash\nfor i in {1..5}; do",
  "bash\n#### 带步长的范围\n```bash\nfor i in {5..50..5}; do",
  "bash\n### 读取行\n```bash\ncat file.txt | while read line; do",
  "bash\n### 死循环\n```bash\nwhile true; do",
  "bash\n## 函数\n### 定义函数\n```bash\nmyfunc() {",
  "bash\n### 返回值\n```bash\nmyfunc() {",
  "bash\n### 引发错误\n```bash\nmyfunc() {",
  "bash\n### 参数",
  "bash\n## 条件语句\n### 条件\n`[[`会返回`0`(假)或`1`(真)，其他任意遵守相同逻辑的程序均可以作为条件，详见示例。",
  "bash\n#### 更多条件",
  "bash\n### 文件条件",
  "bash\n### 示例\n#### 字符串\n```bash\nif [[ -z \"$string\" ]]; then",
  "bash\n#### 组合\n```bash\nif [[ X && Y ]]; then",
  "bash\n#### 相等\n```bash\nif [[ \"$A\" == \"$B\" ]]",
  "bash\n#### 正则\n```bash\nif [[ \"A\" =~ . ]]",
  "bash\n#### 数值\n```bash\nif (( $a < $b )); then",
  "bash\n#### 文件\n```bash\nif [[ -e \"file.txt\" ]]; then",
  "bash\n## 数组\n### 定义数组\n```bash\nFruits=('Apple' 'Banana' 'Orange')",
  "bash\n### 数组使用\n```bash\necho ${Fruits[0]}           # 第一个元素 #0",
  "bash\n### 操作\n```bash\nFruits=(\"${Fruits[@]}\" \"Watermelon\")    # Push",
  "bash\n### 变量\n```bash\nfor i in \"${arrayName[@]}\"; do",
  "bash\n## 字典\n### 定义\n```bash\ndeclare -A sounds",
  "bash\n### 字典使用\n```bash\necho ${sounds[dog]} # 按key取值",
  "bash\n### 遍历\n#### 值遍历\n```bash\nfor val in \"${sounds[@]}\"; do",
  "bash\n#### 键遍历\n```bash\nfor key in \"${!sounds[@]}\"; do",
  "bash\n## 选项\n### 选项\n```bash\nset -o noclobber  # 避免覆盖文件 (echo \"hi\" > foo)",
  "bash\n### 扩展选项\n```bash\nshopt -s nullglob    # 移除不匹配扩展项 ('*.foo' => '')",
  "bash\n## 历史\n### 命令",
  "bash\n### 表达式",
  "bash\n### 操作",
  "bash\n### 切分",
  "bash\n## 杂项\n### 数值计算\n```bash\n$((a + 200))      # $a加上200",
  "bash\n### 子脚本\n```bash\n(cd somedir; echo \"I'm now in $PWD\")",
  "bash\n### 重定向\n```bash\npython hello.py > output.txt   # 标准输出到（文件）",
  "bash\n### 检查命令\n```bash\ncommand -V cd",
  "bash\n### 捕获错误\n```bash\ntrap 'echo Error at about $LINENO' ERR",
  "bash\n### Case/switch\n```bash\ncase \"$1\" in",
  "bash\n### Source relative\n```bash\nsource \"${0%/*}/../share/foo.sh\"",
  "bash\n### printf\n```bash\nprintf \"Hello %s, I'm %s\" Sven Olga",
  "bash\n### Directory of script\n```bash\nDIR=\"${0%/*}\"",
  "bash\n### 获取选项\n```bash\nwhile [[ \"$1\" =~ ^- && ! \"$1\" == \"--\" ]]; do case $1 in",
  "bash\n### Heredoc\n```sh\ncat <<END",
  "bash\n### 读取输入\n```bash\necho -n \"Proceed? [y/n]: \"",
  "bash\n### 特殊变量",
  "bash\n### 返回先前目录\n```bash\ncd -",
  "bash\n### 命令结果检查\n```bash\nif ping -c 1 google.com; then",
  "bash\n### GREP结果检查\n```bash\nif grep -q 'foo' ~/.bash_history; then",
  "bash\n## 更多\n- [Bash-hackers wiki](http://wiki.bash-hackers.org/) _(bash-hackers.org)_\n- [Shell vars](http://wiki.bash-hackers.org/syntax/shellvars) _(bash-hackers.org)_",
  "git\n### 配置\n```bash\ngit config --global \"Your Name\"",
  "git\n### 初始化\n```bash\ngit init",
  "git\n###  提交修改\n```bash\ngit add <file>",
  "git\n### 查看状态、比对\n```bash\ngit status",
  "git\n#### 文件状态缩略信息",
  "git\n## Git Log\n### log 记录和对比\n```bash\ngit log",
  "git\n### log 格式化\n```bash\ngit log <branch_name> --oneline                     # 对提交历史单行排列",
  "git\n#### git log --pretty=format 常用的选项(摘自progit_v2.1.9)",
  "git\n### log 时间和提交者\n```bash\ngit log --since --after     # 显示时间之后的提交",
  "git\n## 版本管理\n### 版本回退、前进\n```bash\ngit reset --hard HEAD^   # 回退到上1版本",
  "git\n### 撤销修改\n```bash\ngit checkout -- <file>   # 撤销修改：误修改工作区文件，未git add/commit",
  "git\n### 删除与恢复\n```bash\ngit rm/add <file>",
  "git\n### 清理工作区\n包括未track也未ignore的文件或文件夹，如各种临时.swp, .patch文件等\n```bash",
  "git\n## 仓库与分支\n### 关联GitHub远程仓库（本地到远程）\n```bash\ngit remote add origin <remote address>  # 在本地工作区目录下按照 GitHub 提示进行关联",
  "git\n### 克隆GitHub远程仓库（远程到本地）\n```bash\ngit clone <remote address>  # git协议速度更快但通常公司内网不允许，https协议速度慢",
  "git\n### 分支管理：创建、切换、查看、合并、删除\n```bash\ngit branch <branch name>       # 创建<branch name>分支",
  "git\n### 解决合并冲突\n合并时报错“分支发生冲突”，首先vim相应文件，修改冲突位置，然后按照git add/commit重新提交，最后删除多余分支即可。\n```bash",
  "git\n### 分支管理：合并后删除分支也在 log 中保留分支记录\n```bash\ngit merge --no-ff -m \"descriptions\" <branch name>",
  "git\n### 开发流程",
  "git\n### Bug分支管理（建立单独分支进行bug修复）\n软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。\n```bash",
  "git\n### Feature分支管理（建立单独分支添加新功能）\n软件开发中，总有无穷无尽的新的功能要不断添加进来。添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。\n```bash",
  "git\n### 协作与分支推送\n#### User 1:\n```bash\ngit remote [-v]                   # 查看远程库信息（-v 查看详细信息）",
  "git\n#### User 2:\n```bash\ngit clone <remote address>      # 克隆到本地（只能克隆master）",
  "git\n#### User 1:\n```bash\ngit add/commit/push          # 推送时报错（与user 2推送的更新冲突）",
  "git\n### 标签管理（常用于版本管理）：查看、创建、操作\n```bash\ngit tag                           # 查看标签",
  "git\n## rebase(换基)\n### 目的\n`rebase`在日常中常用功能主要是两个，多人协同开发定期`rebase master`，以及压缩某分支多个`commit`。\n`git rebase master`常见于多人开发，每个开发人员从`master` `checkout`出自己的分支，开发一段时间后提交至`master`之前最好`rebase`一下，防止冲突，就算真有冲突在本地解决好过强制提交，开发流程中尽量保证master的干净整洁。\n### 案例一\n`master`分支上有三个提交`C1`, `C2`, `C3`\n某一时刻`usr1`在`C3`的`master`分支上`checkout`出新的分支, 用于开发服务端支持`ipv6`新特性, 并提交了`C4`, `C5`",
  "git\n### 案例二\n// TODO\n```bash",
  "git\n#### 提交后分支状态如下\n```markup\n(client branch)",
  "git\n### 其他\n```bash\n# 压缩当前分支的n个commit并合并为1个commit, 常见第一行为pick, 剩下的n-1行为squash",
  "git\n## 杂项\n{column_size: 1}\n### 打patch(补丁)\n#### 生成diff patch文件(git可以识别diff文件)\n```bash\ngit <branch> log -n -p > diff.patch # 生成某分支过去n个commit的文件diff信息至单个diff文件",
  "git\n#### 利用apply打patch\n```bash\ngit apply --check diff.patch    # 检查是否可以正常应用, 无回显证明无冲突",
  "git\n#### 利用--format-patch生成patch, 带commit信息\n```bash\ngit format-patch <branch> -n    # 生成分支<branch>最近的n次commit的patch",
  "git\n#### 利用am打patch\n```bash\ngit apply --check 0001-update-bash.sh.patch # 检查patch是否冲突可用",
  "git\n### bundle(打包)\n该命令会将git工程打包, 默认情况下会打包所有commit记录和track的文件\n不同于简单粗暴tar.gz打包整个文件夹, bundle只打包那些push过的记录",
  "git\n#### bundle也可以打包指定的区间, 至于提交区间有多种表示方式\n```bash\ngit bundle create awesome-cheatsheets.bundle HEAD~10",
  "git\n### 使用GitHub\n```markup\nfork --> clone --> add/commit/push --> pull request",
  "git\n### 其他配置\n```bash\ngit config --global color.ui true  # 显示颜色",
  "git\n### 配置.gitignore文件\n```markup\n/<dir name>/               # 忽略文件夹",
  "git\n#### 文件.gitignore生效后\n```bash\ngit add -f <file>           # 强制添加",
  "git\n### 配置别名\n```bash\ngit config [--global] alias.<alias> '<original command>'  # 为所有工作区/当前工作区配置别名",
  "vim\n### 退出",
  "vim\n### 导航",
  "vim\n#### 单词",
  "vim\n#### 行",
  "vim\n#### 字符",
  "vim\n#### 文档",
  "vim\n#### 窗口",
  "vim\n#### 查找",
  "vim\n#### Tab页",
  "vim\n### 编辑",
  "vim\n### 退出插入模式",
  "vim\n### 剪贴板",
  "vim\n### 视觉模式",
  "vim\n#### 在视觉模式中",
  "vim\n## 操作指令\n### 使用\n这些在正常模式下执行，根据*指令范围*不同，操作指定能操作一定区域的文本。",
  "vim\n### 操作指令列表",
  "vim\n### 示例\n结合*指令范围*来应用操作指令。",
  "vim\n## 文本对象\n### 使用\n文本对象使您可以在文本块中或周围进行操作（使用*操作指令*）。",
  "vim\n### 文本对象",
  "vim\n### Examples",
  "vim\n### Diff",
  "vim\n## 杂项\n{column_size: 2}\n### 折叠",
  "vim\n### 导航",
  "vim\n### 跳转",
  "vim\n### 计数器",
  "vim\n### 窗口",
  "vim\n### 标签",
  "vim\n### 大小写",
  "vim\n### 标记",
  "vim\n### 杂项",
  "vim\n### 命令行",
  "vim\n### 文本对齐\n```\n:center [width]",
  "vim\n### 计算",
  "vim\n### 错误退出\n```\n:cq",
  "vim\n### 拼写检查",
  "vim\n## 更多\n- [Vim cheatsheet](https://vim.rtorr.com/) _(vim.rotrr.com)_\n- [Vim documentation](http://vimdoc.sourceforge.net/htmldoc/) _(vimdoc.sourceforge.net)_",
  "powershell\n### 帮助\n```shell\nGet-Help alias",
  "powershell\n### 文件和路径\n```shell\nGet-ChildItem [path]; ls; dir       # 子对象列表",
  "powershell\n### 句法要素",
  "powershell\n#### 三元运算\n```shell\nswitch(boolExpr) {",
  "powershell\n### 显示选项",
  "powershell\n#### 格式化 + 过滤\n```shell\n# table化输出到文件",
  "powershell\n### 提示和暂停",
  "powershell\n## 语法\n### 变量\n```shell\n$a = 25; $a                                 #=> 25",
  "powershell\n### 参数传递\n```shell\nfunction func($a,$b) {",
  "powershell\n### 属性\n```shell\ngm -input (1..5) -name count                  # 尝试获取属性",
  "powershell\n### 对象、类型和转型\n```shell\n@(Get-Process).Count                           # 集合大小",
  "regex\n### 字符",
  "regex\n### 字符类",
  "regex\n### 预定义字符类",
  "regex\n### 边界匹配器",
  "regex\n### Greedy 数量词\n匹配优先，优先匹配最大长度，匹配尽可能多的内容",
  "regex\n### Reluctant 数量词\n忽略优先，尽可能匹配最少内容，满足下限即成功",
  "regex\n### Possessive 数量词\n占有优先，优先匹配最大长度，放弃备用状态",
  "regex\n### Logical 运算符",
  "regex\n###  特殊构造（非捕获）",
  "regex\n###  环视结构（非捕获）\n环视结构，包括肯定型和否定型，顺序环视和逆序环视，它们只是简单的测试，其中表达式能否在当前的位置匹配后面的内容（顺序），或者前面的内容（逆序），并不改变当前位置。",
  "regex\n## 常见需求\n### 案例\n// TODO",
  "es6\n### 块作用域\n#### Let\n```js\nfunction fn () {",
  "es6\n#### Const\n```js\nconst a = 1",
  "es6\n### 反引号\n#### 字符串模板\n```js\nconst message = `Hello ${name}`",
  "es6\n#### 多行文本\n```js\nconst str = `",
  "es6\n### 二进制和八进制\n```js\nlet bin = 0b1010010",
  "es6\n### 新方法\n#### string的新方法\n```js\n\"hello\".repeat(3)",
  "es6\n### 类\n```js\nclass Circle extends Shape {",
  "es6\n#### 构造器\n```js\nconstructor (radius) {",
  "es6\n#### 方法\n```js\ngetArea () {",
  "es6\n#### 调用父类方法\n```js\nexpand (n) {",
  "es6\n#### 静态方法\n```js\nstatic createFromDiameter(diameter) {",
  "es6\n### 指数计算\n```js\nconst byte = 2 ** 8",
  "es6\n## Promises\n### 创建 promises\n```js\nnew Promise((resolve, reject) => {",
  "es6\n### 使用 promises\n```js\npromise",
  "es6\n### promises 使用 finally\n```js\npromise",
  "es6\n### Promise 方法\n```js\nPromise.all(···)",
  "es6\n### Async-await\n```js\nasync function run () {",
  "es6\n## 解构\n### 解构赋值\n#### Arrays\n```js\nconst [first, last] = ['Nikola', 'Tesla']",
  "es6\n#### Objects\n```js\nlet {title, author} = {",
  "es6\n### 默认值\n```js\nconst scores = [22, 33]",
  "es6\n### 方法参数\n```js\nfunction greet({ name, greeting }) {",
  "es6\n### 方法参数默认值\n```js\nfunction greet({ name = 'Rauno' } = {}) {",
  "es6\n### 为key重新赋值\n```js\nfunction printCoordinates({ left: x, top: y }) {",
  "es6\n### 循环\n```js\nfor (let {title, artist} of songs) {",
  "es6\n### 对象结构\n```js\nconst { id, ...detail } = song;",
  "es6\n## 扩展运算\n### 对象扩展\n#### 使用对象扩展\n```js\nconst options = {",
  "es6\n#### 不使用对象扩展\n```js\nconst options = Object.assign(",
  "es6\n### 数组扩展\n#### 使用数组扩展\n```js\nconst users = [",
  "es6\n#### 不使用数组扩展\n```js\nconst users = admins",
  "es6\n## 函数\n### 参数\n#### 参数默认值\n```js\nfunction greet (name = 'Jerry') {",
  "es6\n#### 余下的参数\n```js\nfunction fn(x, ...y) {",
  "es6\n#### 扩展\n```js\nfn(...[1, 2, 3])",
  "es6\n### 箭头函数\n#### 箭头函数\n```js\nsetTimeout(() => {",
  "es6\n#### 带参数\n```js\nreadFile('text.txt', (err, data) => {",
  "es6\n#### 隐式返回\n```js\nnumbers.map(n => n * 2)",
  "es6\n## 对象\n### 速记语法\n```js\nmodule.exports = { hello, bye }",
  "es6\n### 方法\n```js\nconst App = {",
  "es6\n### Getters 和 setters\n```js\nconst App = {",
  "es6\n### 计算属性名\n```js\nlet event = 'click'",
  "es6\n### 提取值\n```js\nconst fatherJS = { age: 57, name: \"Brendan Eich\" }",
  "es6\n## 模块\n### 导入\n```js\nimport 'helpers'",
  "es6\n### 导出\n```js\nexport default function () { ··· }",
  "es6\n## Generators\n### Generators\n```js\nfunction* idMaker () {",
  "es6\n### For..of 遍历\n```js\nfor (let i of iterable) {",
  "springCloud\n### 项目结构\n项目在一个工程中，通过`module`进行组装。\n```",
  "springCloud\n### 项目结构说明",
  "java8\n### Lambda 表达式\n```java\n(int a) -> a * 2; // 求a乘以2后的值",
  "java8\n#### 如果lambda里面的代码块超过1行，可以配合使用 `{ }` 加 `return`来处理\n```java\n(x, y) -> {",
  "java8\n#### 一个lamdba表达式必须依赖一个具体的功能接口而存在\n```java\ninterface MyMath {",
  "java8\n#### 下面所有的测试都是用到这个`list` :\n```java\nList<String> list = [Bohr, Darwin, Galilei, Tesla, Einstein, Newton]",
  "java8\n### Collections 集合\n#### **sort** `sort(list, comparator)`\n```java\n// 正序",
  "java8\n#### **removeIf**\n```java\nlist.removeIf(w -> w.length() < 6);",
  "java8\n#### **merge** `merge(key, value, remappingFunction)`\n```java\nMap<String, String> names = new HashMap<>();",
  "java8\n### 方法引用 `Class::staticMethod`\n允许引用类方法或者构造函数，引用时候是不执行的\n```java",
  "java8\n### Optional\n在Java, 通常使用`null`表示没有结果，但是如果不检查的话很容易出现`NullPointerException`.\n```java",
  "java8\n## Streams 流式处理\n和`collections`类似, 但有所不同:\n- 不能储存数据",
  "java8\n#### **创建一个stream**\n```java\nStream<Integer> stream = Stream.of(1, 2, 3, 5, 7, 11);",
  "java8\n#### **集合结果集**\n```java\n//返回成一个数组 (::new 是构造函数的引用)",
  "java8\n#### **map** `map(mapper)` 对每个元素进行类型转换\n```java\n// 对每个元素使用 \"toLowerCase\" 处理",
  "java8\n#### **filter** `filter(predicate)` 过滤处理，只保留匹配到的元素\n```java\n// 过掉保留 \"E\" 开头的元素",
  "java8\n#### **reduce** 汇聚处理成为单一返回结果\n```java\nString reduced = stream",
  "java8\n#### **limit** `limit(maxSize)` 保留前`maxSize`个元素\n```java\nres = stream.limit(3);",
  "java8\n#### **skip** 忽略掉前`n`个元素\n```java\nres = strem.skip(2); // 忽略 Bohr 和 Darwin",
  "java8\n#### **distinct** 去重\n```java\nres = Stream.of(1,0,0,1,0,1).distinct();",
  "java8\n#### **sorted** 排序 (必须使用 *Comparable* 接口)\n```java\nres = stream.sorted();",
  "java8\n#### **allMatch** 全匹配\n```java\n// 检查是否每个元素包含“e“",
  "java8\n#### **parallel** 返回一个并行的stream\n#### **findAny** 在并行流上findFirst执行更快\n### 原始类型的 Streams\n原始类型的stream自动封装是低效的 (例如 Stream<Integer>) ，因为它需要对每个元素进行大量拆箱和装箱. 所以最好使用 `IntStream`, `DoubleStream`, 等等.\n#### **初始化**\n```java\nIntStream stream = IntStream.of(1, 2, 3, 5, 7);",
  "java8\n### Grouping 结果集\n#### **Collectors.groupingBy**\n```java\n// 通过长度分组",
  "java8\n#### **Collectors.toSet**\n```java\n// 和之前一样但是使用的是Set",
  "java8\n#### **Collectors.counting** 计算个数\n#### **Collectors.summing__** 计算累加 `summingInt`, `summingLong`, `summingDouble`\n#### **Collectors.averaging__** 计算平均数 `averagingInt`, `averagingLong`, ...\n```java\nCollectors.averagingInt(String::length)",
  "java8\n### 并行 Streams\n#### **创建并行处理stream**\n```java\nStream<String> parStream = list.parallelStream();",
  "java8\n#### **unordered** 能提高计算 `limit`，`distinct`的速度\n```java\nstream.parallelStream().unordered().distinct();",
  "java8\n### 注意引用推测限制\n```java\ninterface Pair<A, B> {",
  "java8\n## LocalDate\n### 简介\n在JAVA中，常用的处理日期和时间的类主要有`Date`，`Calendar`，而在JDK1.8中，新增了`LocalDate`、`LocalTime`、`LocalDateTime` 类的实例是不可变的对象，分别表示使用ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。\n### API\n#### **now()** 静态方法，根据当前时间创建对象\n```java\nLocalDate.now();",
  "java8\n#### **of()** 静态方法，根据指定时间创建对象\n```java\nLocalDate.of(2020, 12, 2);",
  "java8\n#### **plus, minus** 向当前时间添加指定长度时间\n```java\nLocalDate.now().plusDays(30);",
  "java8\n#### **isBefore、isAfter** 比较两个时间\n```java\nLocalDate.now().isAfter(LocalDate.now().minusDays(1))",
  "java8\n### Instant 时间戳\n用于`时间戳`的运算。它是以Unix元年(传统的设定为UTC时区1970年1月1日午夜时分)开始所经历的描述进行运算。\n```java",
  "java8\n### Duration 和 Period\n#### **Duration:** 用于计算两个“时间”间隔\n```java\nInstant now = Instant.now();",
  "java8\n#### **Period:** 用于计算两个“日期”间隔\n```java\nLocalDate now = LocalDate.now();",
  "java8\n### 日期操作\n- **TemporalAdjuster**: 时间校正器。\n- **TemporalAdjusters**: 该类通过静态方法提供了大量的常用 TemporalAdjuster 的实现。",
  "java8\n#### 本月第一天\n```java\nLocalDateTime firstday = date.with(TemporalAdjusters.firstDayOfMonth());",
  "java8\n#### 本月最后一天\n```java\nLocalDateTime lastDay = date.with(TemporalAdjusters.lastDayOfMonth());",
  "java8\n#### 上个月最后一天\n```java\nLocalDateTime next_lastday = date.with(TemporalAdjusters.lastDayOfMonth());",
  "java8\n#### 下个周日\n```java\nLocalDate nextSunday = LocalDate.now().with(TemporalAdjusters.next(DayOfWeek.SUNDAY));",
  "java8\n#### 计算两个日期相差的月份数\n```java\nlong betweenMONTHS = ChronoUnit.MONTHS.between(beforeDate, afterDate);",
  "java8\n### 解析与格式化\n#### 日期格式化成字符串\n```java\nLocalDate now = LocalDate.now();",
  "java8\n#### 字符串解析成时间\n```java\nSystem.out.println(LocalDate.parse(\"2020/12/01\", DateTimeFormatter.ofPattern(\"yyyy/MM/dd\")));",
  "awk\n### 开始\n#### 从netstat命令中提取了如下信息作为用例\n```bash\n$ cat netstat.txt",
  "awk\n### 第一个例子\n其中单引号中的被**大括号**括着的就是`awk`的语句，注意，其只能被**单引号**包含。\n其中的`$1..$n`表示第几例。注：`$0`表示整个行。",
  "awk\n### 格式化输出\n`awk`的格式化输出，和`C`语言的`printf`没什么两样：\n```bash",
  "awk\n## 起步\n### 过滤记录\n#### 过滤条件为：**第3列**的值为`0` && **第6列**的值为`LISTEN`\n```bash\n$ awk '$3==0 && $6==\"LISTEN\" ' netstat.txt",
  "awk\n### 内建变量",
  "awk\n### 指定分隔符\n```bash\n$  awk  'BEGIN{FS=\":\"} {print $1,$3,$6}' /etc/passwd",
  "awk\n## 进阶\n### 字符串匹配\n```bash\n$ awk '$6 ~ /FIN/ || NR==1 {print NR,$4,$5,$6}' OFS=\"\\t\" netstat.txt",
  "awk\n### 折分文件\nawk拆分文件很简单，使用重定向就好了。下面这个例子，是按第6列分隔文件（`group by`，不同值分到不同的文件中），相当的简单（其中的`NR!=1`表示不处理表头）。\n```bash",
  "awk\n### 统计\n下面的命令计算所有的C文件，CPP文件和H文件的文件大小总和。\n```bash",
  "awk\n## 深入\n### awk脚本\n#### 运行前\n```bash\nBEGIN { 这里面放的是执行前的语句 }",
  "awk\n#### 运行中\n```bash\n{ 这里面放的是处理每一行时要执行的语句 }",
  "awk\n#### 运行后\n```bash\nEND {这里面放的是处理完所有的行后要执行的语句 }",
  "awk\n#### 案例\n假设有这么一个文件（学生成绩表）：\n```bash",
  "awk\n### 环境变量\n即然说到了脚本，我们来看看怎么和环境变量交互：（使用`-v`参数和`ENVIRON`，使用`ENVIRON`的环境变量需要`export`）\n```bash",
  "awk\n### 几个小例子\n```bash\n#从file文件中找出长度大于80的行",
  "redis\n### 启动\n```bash\n./redis-server                      # 启动服务",
  "redis\n#### 以配置文件方式启动\n```bash\n./redis-server redis.conf &",
  "redis\n### 登录\n```bash\n./redis-cli           # 登录",
  "redis\n#### 客户端参数",
  "redis\n## 操作\n### string（字符串）",
  "redis\n### list（列表）",
  "redis\n### Client­/Server",
  "redis\n### set（集合）\n显然，`set`会忽略重复元素",
  "redis\n### database（数据库）",
  "redis\n### Script（脚本）\nredis支持`Lua`脚本",
  "redis\n### Hash（哈希表）",
  "redis\n### SortedSet（有序集合）",
  "golang\n### Credits\n大部分例子来源于[A Tour of Go](http://tour.golang.org/), 是`Go`非常优秀的入门教程，如果你是新手，建议你先看看这个教程。\n### 简述\n- 命令式语言\n- 静态类型",
  "golang\n### Hello World\nFile `hello.go`:\n```go",
  "golang\n## 操作符\n### 算术运算",
  "golang\n### 对比",
  "golang\n### 逻辑运算",
  "golang\n### 其他",
  "golang\n## 变量声明\n类型在标识符之后\n```go",
  "golang\n## 函数\n### 函数定义\n#### 一个简单的函数\n```go\nfunc functionName() {}",
  "golang\n#### 带参数函数（同样的，类型在标识符之后）\n```go\nfunc functionName(param1 string, param2 int) {}",
  "golang\n#### 同类型的多个参数\n```go\nfunc functionName(param1, param2 int) {}",
  "golang\n#### 返回值类型声明\n```go\nfunc functionName() int {",
  "golang\n#### 返回多个参数\n```go\nfunc returnMulti() (int, string) {",
  "golang\n#### 只需通过return返回多个命名结果\n```go\nfunc returnMulti2() (n int, s string) {",
  "golang\n### 函数作为值和闭包\n```go\nfunc main() {",
  "golang\n#### 闭包，字面作用域：定义函数时，函数可以访问作用域内的值\n```go\nfunc scope() func() int{",
  "golang\n#### 闭包\n```go\nfunc outer() (func() int, int) {",
  "golang\n### 可变参数函数\n```go\nfunc main() {",
  "golang\n#### 通过在最后一个参数的类型名称前使用`...`，接受零个或多个参数。\n```go\nfunc adder(args ...int) int {",
  "golang\n## 类型\n### 内置类型\n```go\nbool",
  "golang\n### 结构 Struct\ngo没有类`class`，只有结构`struct`，结构可以拥有方法。struct 是一种类型，也是成员变量的集合。\n```go",
  "golang\n#### **匿名struct:**，比`map[string]interface{}`更轻量和安全\n```go\npoint := struct {",
  "golang\n### 指针\n```go\np := Vertex{1, 2}  // p 是一个 Vertex",
  "golang\n#### 指向 Vertex 的指针类型为 *Vertex\n```go\nvar s *Vertex = new(Vertex) // 创建一个指向Vertex实例的指针",
  "golang\n### 类型转换\n```go\nvar i int = 42",
  "golang\n## Packages\n- 每个源文件顶部声明包\n- 可执行文件位于包`main`中",
  "golang\n## 控制结构\n### If\n```go\nfunc main() {",
  "golang\n### Loops\n只有`for`，没有`while`和`until`\n```go",
  "golang\n### Switch\n```go\nswitch operatingSystem {",
  "golang\n#### 与for和if一样，在switch值之前可以有一个赋值语句\n```go\nswitch os := runtime.GOOS; os {",
  "golang\n#### 可以使用对比\n```go\nnumber := 42",
  "golang\n#### 多个case可用逗号分割\n```go\nvar char byte = '?'",
  "golang\n## 集合\n### 数组\n```go\nvar a [10]int // 声明长度为10的数组，长度是类型的一部分",
  "golang\n### 切片\n```go\nvar a []int                      // 声明切片 - 和数组类似，但不指定长度",
  "golang\n### 操作数组和切片\n`len(a)` 返回数组/切片的长度，这是一个内置函数，而不是数组上的属性/方法。\n```go",
  "golang\n### Maps\n```go\nvar m map[string]int",
  "golang\n## 多态\n### 接口\n#### 接口声明\n```go\ntype Awesomizer interface {",
  "golang\n#### 类型不声明实现接口\n```go\ntype Foo struct {}",
  "golang\n#### 如果类型实现所有必需的方法，则它们隐式满足接口\n```go\nfunc (foo Foo) Awesomize() string {",
  "golang\n### 嵌入\nGo中没有`子类`。 而是有`接口`和`结构`嵌入。\n```go",
  "golang\n## 并发\n### Goroutines\n`Goroutines`是轻量级线程（由Go而不是OS管理）。 `go f(a, b)`启动一个新的goroutine，该例程将运行`f`（`f`是一个函数）。\n```go",
  "golang\n### Channels\n#### 非阻塞通道，发送和接收动作是同时发生的，如果没有接收者，发送会一直阻塞\n```go\nch := make(chan int) // 创建一个类型为int的通道",
  "golang\n#### 缓冲通道，如果已写入小于<buffer size>的未读值，则写入不会阻塞。\n```go\nch := make(chan int, 100)",
  "golang\n#### 关闭通道（只有发送者应该关闭）\n```go\nclose(ch)",
  "golang\n#### 从通道读取并测试是否已关闭\n```go\nv, ok := <-ch",
  "golang\n#### 读取通道直至关闭\n```go\nfor i := range ch {",
  "golang\n#### 尝试多种通道操作，如果没有柱塞，则执行相应操作\n```go\nfunc doStuff(channelOut, channelIn chan int) {",
  "golang\n### Channel Axioms\n#### 发送到nil通道将永远阻塞\n```go\nvar c chan string",
  "golang\n#### 接收自nil通道将永远阻塞\n```go\nvar c chan string",
  "golang\n#### 发送到已关闭通道触发panic\n```go\nvar c = make(chan string, 1)",
  "golang\n#### 来自关闭通道的接收立即返回零值\n```go\nvar c = make(chan int, 2)",
  "golang\n## 杂项\n### 错误\n没有异常处理，可能会产生错误的函数只需声明类型为Error的附加返回值即可。 这是`Error`的接口：\n```go",
  "golang\n### 打印\n```go\nfmt.Println(\"Hello, 你好, नमस्ते, Привет, ᎣᏏᏲ\") // 基本打印，结尾换行",
  "golang\n### 反射 - 类型 Switch\n类型switch类似于常规switch语句，但是类型switch中的case指定类型（不是值），并将这些类型与给定接口的类型进行比较。\n```go",
  "golang\n### HTTP Server\n```go\npackage main",
  "RESTful\n## URL设计\n### 动词 + 宾语\nRESTful的核心思想就是，客户端发出的数据操作指令都是\"动词 + 宾语\"的结构。比如，`GET /articles`这个命令，`GET`是动词，`/articles`是宾语。",
  "RESTful\n### 动词的覆盖\n有些客户端只能使用`GET`和`POST`这两种方法，服务器必须接受`POST`模拟其他三个方法（`PUT`、`PATCH`、`DELETE`）。\n通过`X-HTTP-Method-Override`属性，告诉服务器覆盖的是哪种请求。",
  "RESTful\n### 宾语必须是名词\n宾语显然是名称，它是API的URL，是HTTP动词作用的对象。比如，`/articles`这个URL就是正确的，而下面的URL是错误的:\n- /getAllCars",
  "RESTful\n### 复数 URL\n既然URL是名词，那么应该使用复数，还是单数？\n这没有统一的规定，但是常见的操作是读取一个集合，比如`GET /articles`（读取所有文章），这里明显应该是复数。",
  "RESTful\n### 避免多级 URL\n常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。\n```nginx",
  "RESTful\n## 状态码\n### 状态码必须精确\n客户端的每一次请求，服务器都必须给出回应。回应包括 **HTTP状态码**和**数据**两部分。\nHTTP状态码就是一个三位数，分成五个类别。",
  "RESTful\n### 2xx 状态码\n`200`状态码表示操作成功，但是不同的方法可以返回更精确的状态码。",
  "RESTful\n### 3xx 状态码\n#### 应用级别，浏览器会直接跳转",
  "RESTful\n#### API级别",
  "RESTful\n### 4xx 状态码\n`4xx`状态码表示客户端错误，主要有下面几种。",
  "RESTful\n### 5xx 状态码\n`5xx`表示服务端错误。一般来说，API 不会向用户透露服务器的详细信息。",
  "RESTful\n## 服务器响应\n### 响应数据格式\nAPI 返回的数据格式，应该是一个`JSON`对象，所以：\n- 服务器响应时HTTP头`Content-Type`属性设为`application/json`",
  "RESTful\n### 错误时，不返回200状态码\n有一种**不恰当**的做法是，即使发生错误，也返回200状态码，把错误信息放在数据体里面：\n```nginx",
  "RESTful\n### 提供链接\nAPI 的使用者未必知道，URL 是怎么设计的。一个解决方法就是，在回应中，给出相关链接，便于下一步操作。这样的话，用户只要记住一个 URL，就可以发现其他的 URL。这种方法叫做`HATEOAS`。\n举例来说，GitHub 的 API 都在 [api.github.com](api.github.com) 这个域名。访问它，就可以得到其他 URL。",
  "RESTful\n## RESTful 成熟度\n### Richardson 成熟度模型\n[RESTful Web APIs](https://book.douban.com/subject/22139962/)和[RESTful Web Services](https://book.douban.com/subject/2054201/)的作者伦纳德 · 理查德森（Leonard Richardson），曾提出过一个衡量**服务有多么 REST**的 *Richardson 成熟度模型*（[Richardson Maturity Model](https://martinfowler.com/articles/richardsonMaturityModel.html)，RMM）。这个模型的一个用处是，方便那些原本不使用 REST 的服务，能够逐步导入 REST。\nRichardson 将服务接口按照“REST 的程度”，从低到高分为 0 至 3 共 4 级：",
  "RESTful\n### 第 0 级成熟度：The Swamp of Plain Old XML\n医院开放了一个 `/appointmentService` 的 Web API，传入日期、医生姓名作为参数，就可以得到该时间段、该医生的空闲时间。\n```js",
  "RESTful\n### 第 1 级成熟度：Resources\n实际上你可以发现，第 0 级是 RPC 的风格，所以如果需求永远不会变化，也不会增加，那它完全可以良好地工作下去。但是，如果你不想为预约医生之外的其他操作、为获取空闲时间之外的其他信息去编写额外的方法，或者改动现有方法的接口，那就应该考虑一下如何使用 REST 来抽象资源。\n通往 REST 的第一步是引入资源的概念，在 API 中最基本的体现，就是它会围绕着资源而不是过程来设计服务。说得直白一点，你可以理解为服务的 `Endpoint` 应该是一个**名词**而不是动词。此外，每次请求中都应包含资源 ID，所有操作均通过资源 ID 来进行。",
  "RESTful\n### 第 2 级成熟度：HTTP Verbs\n前面说到，第 1 级中遗留的这三个问题，都可以靠引入统一接口来解决，而 HTTP 协议的标准方法便是最常接触到的统一接口。\nHTTP 协议的标准方法是经过精心设计的，它几乎涵盖了资源可能遇到的所有操作场景（这其实更取决于架构师的抽象能力）。",
  "RESTful\n### 第 3 级成熟度：Hypermedia Controls\n或许你第一眼看到这个问题会说，这当然是程序写的啊，我为什么会问这么奇怪的问题。但问题是，REST 并不认同这种已烙在程序员脑海中许久的想法。\nRMM 中的第 3 级成熟度 `Hypermedia Controls`、Fielding 论文中的 `HATEOAS` 和现在提得比较多的`超文本驱动`，其实都是希望能达到这样一种效果：**除了第一个请求是由你在浏览器地址栏输入的信息所驱动的之外，其他的请求都应该能够自己描述清楚后续可能发生的状态转移，由超文本自身来驱动。**",
  "RESTful\n## REST 的不足与争议\n### `争议一` 面向资源只适合做 CRUD\n面向资源的编程思想只适合做 CRUD，只有面向过程、面向对象编程才能处理真正复杂的业务逻辑。原因也很简单，HTTP 的 4 个最基础的命令 POST、GET、PUT 和 DELETE，很容易让人联想到 CRUD 操作。\nREST 涵盖的范围当然远不止于此。不过要说 POST、GET、PUT 和 DELETE 对应于 CRUD，其实也没什么不对，只是我们必须泛化地去理解这个 CRUD：它们涵盖了信息在客户端与服务端之间流动的几种主要方式（比如 POST、GET、PUT 等标准方法），所有基于网络的操作逻辑，都可以通过解决“信息在服务端与客户端之间如何流动”这个问题来理解，有的场景里比较直观，而另一些场景中可能比较抽象。",
  "RESTful\n### `争议二` REST 与 HTTP 完全绑定，不适用于要求高性能传输\n其实，我在很大程度上赞同这个观点，但我并不认为这是 REST 的缺陷，因为锤子不能当扳手用，并不是锤子的质量有问题。\n面向资源编程与协议无关，但是 REST（特指 Fielding 论文中所定义的 REST，而不是泛指面向资源的思想）的确依赖着 HTTP 协议的标准方法、状态码和协议头等各个方面。",
  "RESTful\n### `争议三` REST 不利于事务支持\n其实，这个问题首先要看我们怎么去理解**事务（Transaction）**这个概念了。\n- 如果“事务”指的是数据库那种狭义的刚性 ACID 事务，那分布式系统本身跟它之间就是有矛盾的（CAP 不可兼得）。这是分布式的问题，而不是 REST 的问题。",
  "RESTful\n### `争议四` REST 没有传输可靠性支持\n是的，REST 并没有提供对传输可靠性的支持。在 HTTP 中，你发送出去一个请求，通常会收到一个与之相对的响应，比如 `HTTP/1.1 200 OK` 或者 `HTTP/1.1 404 Not Found` 等。但是，如果你没有收到任何响应，那就无法确定消息到底是没有发送出去，还是没有从服务端返回回来。这其中的关键差别，是服务端到底是否被触发了某些处理？\n应对传输可靠性最简单粗暴的做法，就是把消息再重发一遍。这种简单处理能够成立的前提，是服务具有**幂等性（Idempotency）**，也就是说服务被重复执行多次的效果与执行一次是相等的。",
  "RESTful\n### `争议五` REST 缺乏对资源进行“部分”和“批量”的处理能力\n这个观点我是认同的，而且我认为这很可能是未来面向资源的思想和 API 设计风格的发展方向。\nREST 开创了面向资源的服务风格，却肯定不完美。以 HTTP 协议为基础，虽然给 REST 带来了极大的便捷（不需要额外协议，不需要重复解决一堆基础网络问题，等等），但也成了束缚 REST 的无形牢笼。",
  "RESTful\n#### 第一种束缚，就是缺少对资源的“部分”操作的支持。\n有些时候，我们只是想获得某个用户的姓名，RPC 风格中可以设计一个`getUsernameById`的服务，返回一个字符串。尽管这种服务的通用性实在称不上“设计”二字，但确实可以工作。而要是采用 REST 风格的话，你需要向服务端请求整个用户对象，然后丢弃掉返回结果中的其他属性，这就是一种请求冗余（Overfetching）。\nREST 的应对手段是，通过位于中间节点或客户端缓存来缓解。但这治标不治本，因为这个问题的根源在于，HTTP 协议对请求资源完全没有结构化的描述能力（但有的是非结构化的部分内容获取能力，也就是今天多用于端点续传的Range Header），所以返回资源的哪些内容、以什么数据类型返回等等，都不可能得到协议层面的支持。如果要实现这种能力，你就只能自己在 GET 方法的 Endpoint 上设计各种参数。\n#### 而与此相对的缺陷，也是 HTTP 协议对 REST 的第二种束缚，是对资源的“批量”操作的支持。\n有时候，我们不得不为此而专门设计一些抽象的资源才能应对。\n比如，我们要把某个用户的昵称增加一个“VIP”前缀，那提交一个 PUT 请求修改这个用户的昵称就可以了。但如果我们要给 1000 个用户的昵称加“VIP”前缀时，就不得不先创建一个（比如名为“VIP-Modify-Task”）任务资源，把 1000 个用户的 ID 交给这个任务，最后驱动任务进入执行状态（如果真去调用 1000 次 PUT，等浏览器回应我们 HTTP/1.1 429 Too Many Requests 的时候，老板就要发飙了）。",
  "beautifulCode\n### max(a, b)\n```js\n(b & (a - b >> 31) | a & ~(a - b >> 31))",
  "beautifulCode\n### html随机颜色边框\n```js\n// 命令行中 $$ 等同于 document.querySelectorAll",
  "beautifulCode\n### 评分\n```js\nlet rating = 3;",
  "beautifulCode\n### 值交换\n```js\na = a ^ b",
  "beautifulCode\n### 正则表达式简单解析器",
  "Lisp\n## 构造过程抽象\n程序设计的基本元素\n- 基本表达形式",
  "Lisp\n### 表达式\n```\n(+ 3 5 )",
  "Lisp\n### 命名和环境\n`define`定义变量\n```",
  "Lisp\n### 组合式的求值\n- 求值各个子表达式\n- 从最左表达式的值开始计算",
  "Lisp\n### 复合过程\n**过程定义**为复合操作命名\n```",
  "Lisp\n### 过程应用的代换模型\n树形积累的计算过程称为**代换模型**，帮助领会调用过程，并不是解释器的实际工作方式。\n**正则序求值**，即*完全展开后归约*，先进行代换展开，不先局部计算",
  "Lisp\n### 条件表达式和谓词\n`cond`表示条件\n```",
  "Lisp\n### 牛顿法求平方根\n计算机科学里，更关心行动性的描述。牛顿法采用逐步逼近法，对`x`的平方根有一个猜测`y`，令`y = (x + x/y) / 2`，然后判断`y`够不够接近。\n```",
  "Lisp\n### 过程作为黑箱抽象\n#### **局部名** 局部变量名不影响过程和结果\n#### **内部定义和块结构**\n将所有辅助过程定义放到内部\n```",
  "Lisp\n## 过程与所产生的计算\n### 线性的递归和迭代\n阶乘的定义：\n```",
  "Lisp\n### 树形递归\n另一种常见到的计算模式是`树形递归`，以**斐波那契**数序列的计算为例：\n```",
  "Lisp\n### 最大公约数\n找到两个整数的做大公约数(GCD)的一种方法是对她们做因数分解，并找出公共因子，但存在一种更高效的算法（欧几里得算法）：\n*如果`r`是`a`除以`b`的余数，那么`a`和`b`的GCD正好是`b`和`r`的GCD*，即：",
  "Lisp\n## 用高阶函数做抽象\n### 过程作为参数\n序列求和：\n```",
  "Lisp\n### 用lambda构造过程\n`lambda`和`define`使用同样的方式创建过程，但不为过程创建名字：\n```",
  "Lisp\n#### **用`let`创建局部变量**\n```\n(let ((<var1> <exp1>)",
  "数据密集型应用\n## 可靠性、可扩展性、可维护性\n### 可靠性\n#### 典型期望\n- 应用程序表现出用户所期望的功能。\n- 允许用户犯错，允许用户以出乎意料的方式使用软件。",
  "数据密集型应用\n#### 可以恢复的故障种类\n- 硬件故障\n- 软件错误",
  "数据密集型应用\n### 可扩展性\n可扩展性（Scalability）是用来描述系统应对负载增长能力的术语。\n#### 描述负载\n负载可以用一些称为负载参数（load parameters）的数字来描述。参数的最佳选择取决于系统架构，它可能是每秒向Web服务器发出的请求、数据库中的读写比率、聊天室中同时活跃的用户数量、缓存命中率或其他东西。除此之外，也许平均情况对你很重要，也许你的瓶颈是少数极端场景。\n#### `案例`推特\n用户时间线上展示关注的用户动态，有两种常见方案：\n- 发帖，粉丝上线后关联查询所有关注用户动态，按时间序合并",
  "数据密集型应用\n#### 描述性能\n一旦系统的负载被描述好，就可以研究当负载增加会发生什么：\n- 增加负载参数并保持系统资源（CPU、内存、网络带宽等）不变时，系统性能将受到什么影响？",
  "数据密集型应用\n#### 应对负载的方法\n适应某个级别负载的架构不太可能应付10倍于此的负载。如果你正在开发一个快速增长的服务，那么每次负载发生数量级的增长时，你可能都需要重新考虑架构。\n- **纵向扩展**（scaling up），垂直扩展（vertical scaling），转向更强大的机器",
  "数据密集型应用\n### 可维护性\n软件的大部分开销并不在最初的开发阶段，而是在持续的维护阶段，一般包括：\n- 修复漏洞",
  "数据密集型应用\n## 数据模型与查询语言\n应用每个层都通过提供一个明确的数据模型来隐藏更低层次中的复杂性。这些抽象允许不同的人群有效地协作（例如数据库厂商的工程师和使用数据库的应用程序开发人员）。\n数据模型对上层软件的功能（能做什么，不能做什么）有着至深的影响，所以选择一个适合的数据模型是非常重要的。\n### 关系模型与文档模型\n现在最著名的数据模型可能是SQL。它基于Edgar Codd在1970年提出的关系模型：**数据被组织成关系（SQL中称作表），其中每个关系是元组（SQL中称作行)的无序集合。**\n多年来，在数据存储和查询方面存在着许多相互竞争的方法。在20世纪70年代和80年代初，网络模型和分层模型曾是主要的选择，但关系模型随后占据了主导地位。\n#### NoSQL的诞生\nNoSQL被追溯性地重新解释为不仅是SQL（Not Only SQL）。采用NoSQL数据库的背后有几个驱动因素，其中包括：\n- 需要比关系数据库更好的**可扩展性**，包括非常大的数据集或非常高的写入**吞吐量**",
  "数据密集型应用\n#### 对象关系不匹配\n目前大多数应用程序开发都使用面向对象的编程语言来开发，这导致了对SQL数据模型的普遍批评：如果数据存储在关系表中，那么需要一个笨拙的转换层，处于应用程序代码中的对象和表，行，列的数据库模型之间。**模型之间的不连贯有时被称为阻抗不匹配（impedance mismatch）**\n#### 数据模型选择\n于高度相联的数据，选用文档模型是糟糕的，选用关系模型是可接受的，而选用图形模型是最自然的\n#### 文档模型中的架构灵活性\n文档数据库有时称为无模式（schemaless），但这具有误导性，因为读取数据的代码通常假定某种结构——即存在隐式模式，但不由数据库强制执行。一个更精确的术语是**读时模式（schema-on-read）**，相应的是**写时模式（schema-on-write）**。\n### 数据查询语言\nSQL是一种声明式查询语言，而IMS和CODASYL使用命令式代码来查询数据库。\n#### Web上的声明式查询\n在Web浏览器中，使用声明式CSS样式比使用JavaScript命令式地操作样式要好得多。类似地，在数据库中，使用像SQL这样的声明式查询语言比使用命令式查询API要好得多。\n#### MapReduce查询\nMapReduce是一个由Google推广的编程模型，用于在多台机器上批量处理大规模的数据。一些NoSQL数据存储（包括MongoDB和CouchDB）支持有限形式的MapReduce，作为在多个文档中执行只读查询的机制。\nMapReduce既不是一个声明式的查询语言，也不是一个完全命令式的查询API，而是处于两者之间：查询的逻辑用代码片断来表示，这些代码片段会被处理框架重复性调用。它基于 map （也称为 collect ）和 reduce （也称为 fold 或 inject ）函数，两个函数存在于许多函数式编程语言中。\n### 图数据模型\n随着数据之间的连接变得更加复杂，将数据建模为图形显得更加自然。\n一个图由两种对象组成：",
  "数据密集型应用\n#### 属性图\n在属性图模型中，每个**顶点（vertex）**包括：\n- 唯一的标识符",
  "数据密集型应用\n### 三元组存储和SPARQL\n三元组存储中，所有信息都以非常简单的三部分表示形式存储（主语，谓语，宾语）。\n三元组的**主语**相当于图中的一个**顶点**。而**宾语**是下面两者之一：",
  "数据密集型应用\n## 存储与检索\n### 驱动数据库的数据结构\n世界上最简单的数据库可以用两个Bash函数实现：\n```bash",
  "数据密集型应用\n### 哈希索引\n最简单的索引策略就是：保留一个内存中的哈希映射，其中每个键都映射到一个数据文件中的字节偏移量，指明了可以找到对应值的位置。\n#### 避免最终用完磁盘空间\n一种好的解决方案是：\n- 将日志分为特定大小的段",
  "数据密集型应用\n#### 实践中的问题\n- 文件格式\n- CSV不是日志的最佳格式。使用二进制格式更快，更简单，首先以字节为单位对字符串的长度进行编码，然后使用原始字符串（不需要转义）。",
  "数据密集型应用\n#### 哈希表索引局限性\n- 散列表必须能放进内存\n- 范围查询效率不高\n### SSTables和LSM树\n现在对段文件的格式做一个简单的改变：要求键值对的序列**按键排序**。\n这个格式称为排序字符串表（Sorted String Table），简称SSTable。我们还要求每个键只在每个合并的段文件中出现一次（压缩过程已经保证），与散列比有以下优势：",
  "数据密集型应用\n### 构建和维护SSTables\n- 写入时，将其添加到内存中的平衡树数据结构（例如，红黑树）。这个内存树有时被称为**内存表**（memtable）。\n- 当内存表大于某个**阈值**（通常为几兆字节）时，将其作为SSTable文件**写入磁盘**。新的SSTable文件成为数据库的最新部分。当SSTable被写入磁盘时，写入可以继续到一个新的内存表实例。",
  "数据密集型应用\n### 用SSTables制作LSM树\n**日志结构合并树**（或LSM树）的基础上，建立在以前的工作上日志结构的文件系统。基于这种合并和压缩排序文件原理的存储引擎通常被称为LSM存储引擎。\n`Lucene`是`Elasticsearch`和`Solr`使用的一种全文搜索的索引引擎，它使用类似的方法来存储它的词典。全文索引比键值索引复杂得多，但是基于类似的想法：在搜索查询中给出一个单词，找到提及单词的所有文档（网页，产品描述等）。在Lucene中，从术语到发布列表的这种映射保存在SSTable类的有序文件中，根据需要在后台合并。\n### 性能优化\n查找不存在的键时，必须遍历内存表和所有文件段，为了优化这种访问，存储引擎通常使用额外的Bloom过滤器。\n还有不同的策略来确定SSTables如何被压缩和合并的顺序和时间。\n### B树\n在几乎所有的关系数据库中，它们仍然是标准的索引实现，许多非关系数据库也使用它们。\nB树将数据库分解成固定大小的块或页面，传统上大小为4KB（有时会更大），并且一次只能读取或写入一个页面。",
  "数据密集型应用\n#### 更新数据\n- 搜索包含该键的叶页\n- 更改该页中的值"
]